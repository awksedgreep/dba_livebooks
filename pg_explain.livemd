<!-- livebook:{"autosave_interval_s":60} -->

# Explain DB PostgreSQL

```elixir
Mix.install([
  {:kino_db, "~> 0.2.6"},
  {:postgrex, "~> 0.17.4"},
  {:kino_vega_lite, "~> 0.1.11"}
])
```

## Basic DB Information

### Explain DB

##### It's like explain query, but for your entire database.

### Connect to your DB here

<!-- livebook:{"attrs":"eyJkYXRhYmFzZSI6ImNoaW5vb2siLCJob3N0bmFtZSI6ImxvY2FsaG9zdCIsInBhc3N3b3JkX3NlY3JldCI6IiIsInBvcnQiOjU0MzIsInR5cGUiOiJwb3N0Z3JlcyIsInVzZV9pcHY2IjpmYWxzZSwidXNlcm5hbWUiOiJtYXJrLmNvdG5lciIsInZhcmlhYmxlIjoiY29ubiJ9","chunks":null,"kind":"Elixir.KinoDB.ConnectionCell","livebook_object":"smart_cell"} -->

```elixir
opts = [
  hostname: "localhost",
  port: 5432,
  username: "mark.cotner",
  password: "",
  database: "chinook"
]

{:ok, conn} = Kino.start_child({Postgrex, opts})
```

### Full Version

The current database version is :

<!-- livebook:{"attrs":"eyJjYWNoZV9xdWVyeSI6dHJ1ZSwiY29ubmVjdGlvbiI6eyJ0eXBlIjoicG9zdGdyZXMiLCJ2YXJpYWJsZSI6ImNvbm4ifSwicXVlcnkiOiJTRUxFQ1QgdmVyc2lvbigpIiwicmVzdWx0X3ZhcmlhYmxlIjoiZGJfdmVyc2lvbiIsInRpbWVvdXQiOm51bGx9","chunks":null,"kind":"Elixir.KinoDB.SQLCell","livebook_object":"smart_cell"} -->

```elixir
db_version = Postgrex.query!(conn, "SELECT version()", [])
```

### Major and Minor Versions

Extract major and minor versions from settings

<!-- livebook:{"attrs":"eyJjYWNoZV9xdWVyeSI6dHJ1ZSwiY29ubmVjdGlvbiI6eyJ0eXBlIjoicG9zdGdyZXMiLCJ2YXJpYWJsZSI6ImNvbm4ifSwicXVlcnkiOiJTRUxFQ1RcbiBsZWZ0KHNldHRpbmcsIDIpOjppbnQgQVMgbWFqb3JfdmVyc2lvbiwgXG4gcmlnaHQoc2V0dGluZywgMyk6OmludCBBUyBtaW5vcl92ZXJzaW9uIFxuRlJPTVxuIHBnX3NldHRpbmdzIFxuV0hFUkVcbiBuYW1lID0gJ3NlcnZlcl92ZXJzaW9uX251bSc7IiwicmVzdWx0X3ZhcmlhYmxlIjoibWFqb3JfYW5kX21pbm9yIiwidGltZW91dCI6bnVsbH0","chunks":null,"kind":"Elixir.KinoDB.SQLCell","livebook_object":"smart_cell"} -->

```elixir
major_and_minor =
  Postgrex.query!(
    conn,
    """
    SELECT
     left(setting, 2)::int AS major_version, 
     right(setting, 3)::int AS minor_version 
    FROM
     pg_settings 
    WHERE
     name = 'server_version_num';
    """,
    []
  )
```

### Version Comparison

This gets the latest version of PostgreSQL and compares it to yours.

```elixir
Application.ensure_all_started(:inets)
Application.ensure_all_started(:ssl)

{:ok, {{~c"HTTP/1.1", 200, ~c"OK"}, _headers, body}} =
  :httpc.request(:get, {~c"http://apt.postgresql.org/pub/latest/", []}, [], [])

[result] = Regex.run(~r/postgresql-[^\.+]*/, to_string(body), [])
{version, _} = Integer.parse(String.slice(result, 11..12))
[[major, minor]] = major_and_minor.rows

if major <= version - 3 do
  IO.puts("The latest PostgreSQL version is #{version}")
  IO.puts("Consider upgrading to at least PostgreSQL #{version - 2}")
else
  IO.puts("The latest PostgreSQL version is #{version}")
  IO.puts("Version #{major} a newish version")
end
```

### Verify databases

Is this the expected list of databases on your server and the expected number of connections?

<!-- livebook:{"attrs":"eyJjYWNoZV9xdWVyeSI6dHJ1ZSwiY29ubmVjdGlvbiI6eyJ0eXBlIjoicG9zdGdyZXMiLCJ2YXJpYWJsZSI6ImNvbm4ifSwicXVlcnkiOiJTRUxFQ1QgZGF0bmFtZSwgbnVtYmFja2VuZHMgQVMgY29ubmVjdGlvbnMgRlJPTSBwZ19zdGF0X2RhdGFiYXNlIFdIRVJFIGRhdG5hbWUgbm90IGluICgndGVtcGxhdGUwJywgJ3RlbXBsYXRlMScsICd0ZW1wbGF0ZTInLCAncG9zdGdyZXMnKSIsInJlc3VsdF92YXJpYWJsZSI6ImRiX2xpc3QiLCJ0aW1lb3V0IjpudWxsfQ","chunks":null,"kind":"Elixir.KinoDB.SQLCell","livebook_object":"smart_cell"} -->

```elixir
db_list =
  Postgrex.query!(
    conn,
    "SELECT datname, numbackends AS connections FROM pg_stat_database WHERE datname not in ('template0', 'template1', 'template2', 'postgres')",
    []
  )
```

## Database Bloat

### How bloated are my tables?

<!-- livebook:{"attrs":"eyJjYWNoZV9xdWVyeSI6dHJ1ZSwiY29ubmVjdGlvbiI6eyJ0eXBlIjoicG9zdGdyZXMiLCJ2YXJpYWJsZSI6ImNvbm4ifSwicXVlcnkiOiJTRUxFQ1QgY3VycmVudF9kYXRhYmFzZSgpLCBzY2hlbWFuYW1lLCB0YmxuYW1lLCBicyp0YmxwYWdlcyBBUyByZWFsX3NpemUsXG4gICh0YmxwYWdlcy1lc3RfdGJscGFnZXMpKmJzIEFTIGV4dHJhX3NpemUsXG4gIENBU0UgV0hFTiB0YmxwYWdlcyA+IDAgQU5EIHRibHBhZ2VzIC0gZXN0X3RibHBhZ2VzID4gMFxuICAgIFRIRU4gMTAwICogKHRibHBhZ2VzIC0gZXN0X3RibHBhZ2VzKS90YmxwYWdlczo6ZmxvYXRcbiAgICBFTFNFIDBcbiAgRU5EIEFTIGV4dHJhX3BjdCwgZmlsbGZhY3RvcixcbiAgQ0FTRSBXSEVOIHRibHBhZ2VzIC0gZXN0X3RibHBhZ2VzX2ZmID4gMFxuICAgIFRIRU4gKHRibHBhZ2VzLWVzdF90YmxwYWdlc19mZikqYnNcbiAgICBFTFNFIDBcbiAgRU5EIEFTIGJsb2F0X3NpemUsXG4gIENBU0UgV0hFTiB0YmxwYWdlcyA+IDAgQU5EIHRibHBhZ2VzIC0gZXN0X3RibHBhZ2VzX2ZmID4gMFxuICAgIFRIRU4gMTAwICogKHRibHBhZ2VzIC0gZXN0X3RibHBhZ2VzX2ZmKS90YmxwYWdlczo6ZmxvYXRcbiAgICBFTFNFIDBcbiAgRU5EIEFTIGJsb2F0X3BjdCwgaXNfbmFcbiAgLS0gLCB0cGxfaGRyX3NpemUsIHRwbF9kYXRhX3NpemUsIChwc3QpLmZyZWVfcGVyY2VudCArIChwc3QpLmRlYWRfdHVwbGVfcGVyY2VudCBBUyByZWFsX2ZyYWcgLS0gKERFQlVHIElORk8pXG5GUk9NIChcbiAgU0VMRUNUIGNlaWwoIHJlbHR1cGxlcyAvICggKGJzLXBhZ2VfaGRyKS90cGxfc2l6ZSApICkgKyBjZWlsKCB0b2FzdHR1cGxlcyAvIDQgKSBBUyBlc3RfdGJscGFnZXMsXG4gICAgY2VpbCggcmVsdHVwbGVzIC8gKCAoYnMtcGFnZV9oZHIpKmZpbGxmYWN0b3IvKHRwbF9zaXplKjEwMCkgKSApICsgY2VpbCggdG9hc3R0dXBsZXMgLyA0ICkgQVMgZXN0X3RibHBhZ2VzX2ZmLFxuICAgIHRibHBhZ2VzLCBmaWxsZmFjdG9yLCBicywgdGJsaWQsIHNjaGVtYW5hbWUsIHRibG5hbWUsIGhlYXBwYWdlcywgdG9hc3RwYWdlcywgaXNfbmFcbiAgICAtLSAsIHRwbF9oZHJfc2l6ZSwgdHBsX2RhdGFfc2l6ZSwgcGdzdGF0dHVwbGUodGJsaWQpIEFTIHBzdCAtLSAoREVCVUcgSU5GTylcbiAgRlJPTSAoXG4gICAgU0VMRUNUXG4gICAgICAoIDQgKyB0cGxfaGRyX3NpemUgKyB0cGxfZGF0YV9zaXplICsgKDIqbWEpXG4gICAgICAgIC0gQ0FTRSBXSEVOIHRwbF9oZHJfc2l6ZSVtYSA9IDAgVEhFTiBtYSBFTFNFIHRwbF9oZHJfc2l6ZSVtYSBFTkRcbiAgICAgICAgLSBDQVNFIFdIRU4gY2VpbCh0cGxfZGF0YV9zaXplKTo6aW50JW1hID0gMCBUSEVOIG1hIEVMU0UgY2VpbCh0cGxfZGF0YV9zaXplKTo6aW50JW1hIEVORFxuICAgICAgKSBBUyB0cGxfc2l6ZSwgYnMgLSBwYWdlX2hkciBBUyBzaXplX3Blcl9ibG9jaywgKGhlYXBwYWdlcyArIHRvYXN0cGFnZXMpIEFTIHRibHBhZ2VzLCBoZWFwcGFnZXMsXG4gICAgICB0b2FzdHBhZ2VzLCByZWx0dXBsZXMsIHRvYXN0dHVwbGVzLCBicywgcGFnZV9oZHIsIHRibGlkLCBzY2hlbWFuYW1lLCB0YmxuYW1lLCBmaWxsZmFjdG9yLCBpc19uYVxuICAgICAgLS0gLCB0cGxfaGRyX3NpemUsIHRwbF9kYXRhX3NpemVcbiAgICBGUk9NIChcbiAgICAgIFNFTEVDVFxuICAgICAgICB0Ymwub2lkIEFTIHRibGlkLCBucy5uc3BuYW1lIEFTIHNjaGVtYW5hbWUsIHRibC5yZWxuYW1lIEFTIHRibG5hbWUsIHRibC5yZWx0dXBsZXMsXG4gICAgICAgIHRibC5yZWxwYWdlcyBBUyBoZWFwcGFnZXMsIGNvYWxlc2NlKHRvYXN0LnJlbHBhZ2VzLCAwKSBBUyB0b2FzdHBhZ2VzLFxuICAgICAgICBjb2FsZXNjZSh0b2FzdC5yZWx0dXBsZXMsIDApIEFTIHRvYXN0dHVwbGVzLFxuICAgICAgICBjb2FsZXNjZShzdWJzdHJpbmcoXG4gICAgICAgICAgYXJyYXlfdG9fc3RyaW5nKHRibC5yZWxvcHRpb25zLCAnICcpXG4gICAgICAgICAgRlJPTSAnZmlsbGZhY3Rvcj0oWzAtOV0rKScpOjpzbWFsbGludCwgMTAwKSBBUyBmaWxsZmFjdG9yLFxuICAgICAgICBjdXJyZW50X3NldHRpbmcoJ2Jsb2NrX3NpemUnKTo6bnVtZXJpYyBBUyBicyxcbiAgICAgICAgQ0FTRSBXSEVOIHZlcnNpb24oKX4nbWluZ3czMicgT1IgdmVyc2lvbigpfic2NC1iaXR8eDg2XzY0fHBwYzY0fGlhNjR8YW1kNjQnIFRIRU4gOCBFTFNFIDQgRU5EIEFTIG1hLFxuICAgICAgICAyNCBBUyBwYWdlX2hkcixcbiAgICAgICAgMjMgKyBDQVNFIFdIRU4gTUFYKGNvYWxlc2NlKHMubnVsbF9mcmFjLDApKSA+IDAgVEhFTiAoIDcgKyBjb3VudChzLmF0dG5hbWUpICkgLyA4IEVMU0UgMDo6aW50IEVORFxuICAgICAgICAgICArIENBU0UgV0hFTiBib29sX29yKGF0dC5hdHRuYW1lID0gJ29pZCcgYW5kIGF0dC5hdHRudW0gPCAwKSBUSEVOIDQgRUxTRSAwIEVORCBBUyB0cGxfaGRyX3NpemUsXG4gICAgICAgIHN1bSggKDEtY29hbGVzY2Uocy5udWxsX2ZyYWMsIDApKSAqIGNvYWxlc2NlKHMuYXZnX3dpZHRoLCAwKSApIEFTIHRwbF9kYXRhX3NpemUsXG4gICAgICAgIGJvb2xfb3IoYXR0LmF0dHR5cGlkID0gJ3BnX2NhdGFsb2cubmFtZSc6OnJlZ3R5cGUpXG4gICAgICAgICAgT1Igc3VtKENBU0UgV0hFTiBhdHQuYXR0bnVtID4gMCBUSEVOIDEgRUxTRSAwIEVORCkgPD4gY291bnQocy5hdHRuYW1lKSBBUyBpc19uYVxuICAgICAgRlJPTSBwZ19hdHRyaWJ1dGUgQVMgYXR0XG4gICAgICAgIEpPSU4gcGdfY2xhc3MgQVMgdGJsIE9OIGF0dC5hdHRyZWxpZCA9IHRibC5vaWRcbiAgICAgICAgSk9JTiBwZ19uYW1lc3BhY2UgQVMgbnMgT04gbnMub2lkID0gdGJsLnJlbG5hbWVzcGFjZVxuICAgICAgICBMRUZUIEpPSU4gcGdfc3RhdHMgQVMgcyBPTiBzLnNjaGVtYW5hbWU9bnMubnNwbmFtZVxuICAgICAgICAgIEFORCBzLnRhYmxlbmFtZSA9IHRibC5yZWxuYW1lIEFORCBzLmluaGVyaXRlZD1mYWxzZSBBTkQgcy5hdHRuYW1lPWF0dC5hdHRuYW1lXG4gICAgICAgIExFRlQgSk9JTiBwZ19jbGFzcyBBUyB0b2FzdCBPTiB0YmwucmVsdG9hc3RyZWxpZCA9IHRvYXN0Lm9pZFxuICAgICAgV0hFUkUgTk9UIGF0dC5hdHRpc2Ryb3BwZWRcbiAgICAgICAgQU5EIHRibC5yZWxraW5kIGluICgncicsJ20nKVxuICAgICAgR1JPVVAgQlkgMSwyLDMsNCw1LDYsNyw4LDksMTBcbiAgICAgIE9SREVSIEJZIDIsM1xuICAgICkgQVMgc1xuICApIEFTIHMyXG4pIEFTIHMzXG4tLSBXSEVSRSBOT1QgaXNfbmFcbi0tICAgQU5EIHRibHBhZ2VzKigocHN0KS5mcmVlX3BlcmNlbnQgKyAocHN0KS5kZWFkX3R1cGxlX3BlcmNlbnQpOjpmbG9hdDQvMTAwID49IDFcbldIRVJFXG4gc2NoZW1hbmFtZSBOT1QgSU4gKCdpbmZvcm1hdGlvbl9zY2hlbWEnLCAncGdfY2F0YWxvZycpXG5PUkRFUiBCWSBleHRyYV9wY3QgREVTQzsiLCJyZXN1bHRfdmFyaWFibGUiOiJ0YWJsZV9ibG9hdCIsInRpbWVvdXQiOm51bGx9","chunks":null,"kind":"Elixir.KinoDB.SQLCell","livebook_object":"smart_cell"} -->

```elixir
table_bloat =
  Postgrex.query!(
    conn,
    """
    SELECT current_database(), schemaname, tblname, bs*tblpages AS real_size,
      (tblpages-est_tblpages)*bs AS extra_size,
      CASE WHEN tblpages > 0 AND tblpages - est_tblpages > 0
        THEN 100 * (tblpages - est_tblpages)/tblpages::float
        ELSE 0
      END AS extra_pct, fillfactor,
      CASE WHEN tblpages - est_tblpages_ff > 0
        THEN (tblpages-est_tblpages_ff)*bs
        ELSE 0
      END AS bloat_size,
      CASE WHEN tblpages > 0 AND tblpages - est_tblpages_ff > 0
        THEN 100 * (tblpages - est_tblpages_ff)/tblpages::float
        ELSE 0
      END AS bloat_pct, is_na
      -- , tpl_hdr_size, tpl_data_size, (pst).free_percent + (pst).dead_tuple_percent AS real_frag -- (DEBUG INFO)
    FROM (
      SELECT ceil( reltuples / ( (bs-page_hdr)/tpl_size ) ) + ceil( toasttuples / 4 ) AS est_tblpages,
        ceil( reltuples / ( (bs-page_hdr)*fillfactor/(tpl_size*100) ) ) + ceil( toasttuples / 4 ) AS est_tblpages_ff,
        tblpages, fillfactor, bs, tblid, schemaname, tblname, heappages, toastpages, is_na
        -- , tpl_hdr_size, tpl_data_size, pgstattuple(tblid) AS pst -- (DEBUG INFO)
      FROM (
        SELECT
          ( 4 + tpl_hdr_size + tpl_data_size + (2*ma)
            - CASE WHEN tpl_hdr_size%ma = 0 THEN ma ELSE tpl_hdr_size%ma END
            - CASE WHEN ceil(tpl_data_size)::int%ma = 0 THEN ma ELSE ceil(tpl_data_size)::int%ma END
          ) AS tpl_size, bs - page_hdr AS size_per_block, (heappages + toastpages) AS tblpages, heappages,
          toastpages, reltuples, toasttuples, bs, page_hdr, tblid, schemaname, tblname, fillfactor, is_na
          -- , tpl_hdr_size, tpl_data_size
        FROM (
          SELECT
            tbl.oid AS tblid, ns.nspname AS schemaname, tbl.relname AS tblname, tbl.reltuples,
            tbl.relpages AS heappages, coalesce(toast.relpages, 0) AS toastpages,
            coalesce(toast.reltuples, 0) AS toasttuples,
            coalesce(substring(
              array_to_string(tbl.reloptions, ' ')
              FROM 'fillfactor=([0-9]+)')::smallint, 100) AS fillfactor,
            current_setting('block_size')::numeric AS bs,
            CASE WHEN version()~'mingw32' OR version()~'64-bit|x86_64|ppc64|ia64|amd64' THEN 8 ELSE 4 END AS ma,
            24 AS page_hdr,
            23 + CASE WHEN MAX(coalesce(s.null_frac,0)) > 0 THEN ( 7 + count(s.attname) ) / 8 ELSE 0::int END
               + CASE WHEN bool_or(att.attname = 'oid' and att.attnum < 0) THEN 4 ELSE 0 END AS tpl_hdr_size,
            sum( (1-coalesce(s.null_frac, 0)) * coalesce(s.avg_width, 0) ) AS tpl_data_size,
            bool_or(att.atttypid = 'pg_catalog.name'::regtype)
              OR sum(CASE WHEN att.attnum > 0 THEN 1 ELSE 0 END) <> count(s.attname) AS is_na
          FROM pg_attribute AS att
            JOIN pg_class AS tbl ON att.attrelid = tbl.oid
            JOIN pg_namespace AS ns ON ns.oid = tbl.relnamespace
            LEFT JOIN pg_stats AS s ON s.schemaname=ns.nspname
              AND s.tablename = tbl.relname AND s.inherited=false AND s.attname=att.attname
            LEFT JOIN pg_class AS toast ON tbl.reltoastrelid = toast.oid
          WHERE NOT att.attisdropped
            AND tbl.relkind in ('r','m')
          GROUP BY 1,2,3,4,5,6,7,8,9,10
          ORDER BY 2,3
        ) AS s
      ) AS s2
    ) AS s3
    -- WHERE NOT is_na
    --   AND tblpages*((pst).free_percent + (pst).dead_tuple_percent)::float4/100 >= 1
    WHERE
     schemaname NOT IN ('information_schema', 'pg_catalog')
    ORDER BY extra_pct DESC;
    """,
    []
  )
```

<!-- livebook:{"attrs":"eyJjaGFydF90aXRsZSI6IlRhYmxlIEJsb2F0IiwiaGVpZ2h0IjpudWxsLCJsYXllcnMiOlt7ImFjdGl2ZSI6dHJ1ZSwiY2hhcnRfdHlwZSI6ImJhciIsImNvbG9yX2ZpZWxkIjpudWxsLCJjb2xvcl9maWVsZF9hZ2dyZWdhdGUiOm51bGwsImNvbG9yX2ZpZWxkX2JpbiI6bnVsbCwiY29sb3JfZmllbGRfc2NhbGVfc2NoZW1lIjpudWxsLCJjb2xvcl9maWVsZF90eXBlIjpudWxsLCJkYXRhX3ZhcmlhYmxlIjoidGFibGVfYmxvYXQiLCJnZW9kYXRhX2NvbG9yIjoiYmx1ZSIsImxhdGl0dWRlX2ZpZWxkIjpudWxsLCJsb25naXR1ZGVfZmllbGQiOm51bGwsInhfZmllbGQiOiJ0YmxuYW1lIiwieF9maWVsZF9hZ2dyZWdhdGUiOm51bGwsInhfZmllbGRfYmluIjpudWxsLCJ4X2ZpZWxkX3NjYWxlX3R5cGUiOm51bGwsInhfZmllbGRfdHlwZSI6Im5vbWluYWwiLCJ5X2ZpZWxkIjoiYmxvYXRfcGN0IiwieV9maWVsZF9hZ2dyZWdhdGUiOm51bGwsInlfZmllbGRfYmluIjpudWxsLCJ5X2ZpZWxkX3NjYWxlX3R5cGUiOm51bGwsInlfZmllbGRfdHlwZSI6InF1YW50aXRhdGl2ZSJ9XSwidmxfYWxpYXMiOiJFbGl4aXIuVmVnYUxpdGUiLCJ3aWR0aCI6NzAwfQ","chunks":null,"kind":"Elixir.KinoVegaLite.ChartCell","livebook_object":"smart_cell"} -->

```elixir
VegaLite.new(width: 700, title: "Table Bloat")
|> VegaLite.data_from_values(table_bloat, only: ["tblname", "bloat_pct"])
|> VegaLite.mark(:bar)
|> VegaLite.encode_field(:x, "tblname", type: :nominal)
|> VegaLite.encode_field(:y, "bloat_pct", type: :quantitative)
```

```elixir
# IO.inspect(table_bloat)
for row <- table_bloat.rows do
  [_db, schema, table, _, _, pct, _, _, _, _] = row

  if pct > 10 do
    IO.puts("Repack the following tables #{schema}.#{table};")
  end
end
```

### How bloated are my indexes?

<!-- livebook:{"attrs":"eyJjYWNoZV9xdWVyeSI6dHJ1ZSwiY29ubmVjdGlvbiI6eyJ0eXBlIjoicG9zdGdyZXMiLCJ2YXJpYWJsZSI6ImNvbm4ifSwicXVlcnkiOiJTRUxFQ1QgY3VycmVudF9kYXRhYmFzZSgpLCBuc3BuYW1lIEFTIHNjaGVtYW5hbWUsIHRibG5hbWUsIGlkeG5hbWUsIGJzKihyZWxwYWdlcyk6OmJpZ2ludCBBUyByZWFsX3NpemUsXG4gIGJzKihyZWxwYWdlcy1lc3RfcGFnZXMpOjpiaWdpbnQgQVMgZXh0cmFfc2l6ZSxcbiAgMTAwLjAgKiAocmVscGFnZXMtZXN0X3BhZ2VzKTo6ZmxvYXQgLyByZWxwYWdlczo6ZmxvYXQgQVMgZXh0cmFfcGN0LFxuICBmaWxsZmFjdG9yLFxuICBDQVNFIFdIRU4gcmVscGFnZXMgPiBlc3RfcGFnZXNfZmZcbiAgICBUSEVOIGJzKihyZWxwYWdlcy1lc3RfcGFnZXNfZmYpXG4gICAgRUxTRSAwXG4gIEVORCBBUyBibG9hdF9zaXplLFxuICAoMTAwICogKHJlbHBhZ2VzLWVzdF9wYWdlc19mZik6OmZsb2F0KSAvIHJlbHBhZ2VzOjpmbG9hdCBBUyBibG9hdF9wY3QsXG4gIGlzX25hXG4gIC0tICwgMTAwLShwc3QpLmF2Z19sZWFmX2RlbnNpdHkgQVMgcHN0X2F2Z19ibG9hdCwgZXN0X3BhZ2VzLCBpbmRleF90dXBsZV9oZHJfYm0sIG1heGFsaWduLCBwYWdlaGRyLCBudWxsZGF0YXdpZHRoLCBudWxsZGF0YWhkcndpZHRoLCByZWx0dXBsZXMsIHJlbHBhZ2VzIC0tIChERUJVRyBJTkZPKVxuRlJPTSAoXG4gIFNFTEVDVCBjb2FsZXNjZSgxICtcbiAgICAgICAgIGNlaWwocmVsdHVwbGVzL2Zsb29yKChicy1wYWdlb3BxZGF0YS1wYWdlaGRyKS8oNCtudWxsZGF0YWhkcndpZHRoKTo6ZmxvYXQpKSwgMCAtLSBJdGVtSWREYXRhIHNpemUgKyBjb21wdXRlZCBhdmcgc2l6ZSBvZiBhIHR1cGxlIChudWxsZGF0YWhkcndpZHRoKVxuICAgICAgKSBBUyBlc3RfcGFnZXMsXG4gICAgICBjb2FsZXNjZSgxICtcbiAgICAgICAgIGNlaWwocmVsdHVwbGVzL2Zsb29yKChicy1wYWdlb3BxZGF0YS1wYWdlaGRyKSpmaWxsZmFjdG9yLygxMDAqKDQrbnVsbGRhdGFoZHJ3aWR0aCk6OmZsb2F0KSkpLCAwXG4gICAgICApIEFTIGVzdF9wYWdlc19mZixcbiAgICAgIGJzLCBuc3BuYW1lLCB0YmxuYW1lLCBpZHhuYW1lLCByZWxwYWdlcywgZmlsbGZhY3RvciwgaXNfbmFcbiAgICAgIC0tICwgcGdzdGF0aW5kZXgoaWR4b2lkKSBBUyBwc3QsIGluZGV4X3R1cGxlX2hkcl9ibSwgbWF4YWxpZ24sIHBhZ2VoZHIsIG51bGxkYXRhd2lkdGgsIG51bGxkYXRhaGRyd2lkdGgsIHJlbHR1cGxlcyAtLSAoREVCVUcgSU5GTylcbiAgRlJPTSAoXG4gICAgICBTRUxFQ1QgbWF4YWxpZ24sIGJzLCBuc3BuYW1lLCB0YmxuYW1lLCBpZHhuYW1lLCByZWx0dXBsZXMsIHJlbHBhZ2VzLCBpZHhvaWQsIGZpbGxmYWN0b3IsXG4gICAgICAgICAgICAoIGluZGV4X3R1cGxlX2hkcl9ibSArXG4gICAgICAgICAgICAgICAgbWF4YWxpZ24gLSBDQVNFIC0tIEFkZCBwYWRkaW5nIHRvIHRoZSBpbmRleCB0dXBsZSBoZWFkZXIgdG8gYWxpZ24gb24gTUFYQUxJR05cbiAgICAgICAgICAgICAgICAgIFdIRU4gaW5kZXhfdHVwbGVfaGRyX2JtJW1heGFsaWduID0gMCBUSEVOIG1heGFsaWduXG4gICAgICAgICAgICAgICAgICBFTFNFIGluZGV4X3R1cGxlX2hkcl9ibSVtYXhhbGlnblxuICAgICAgICAgICAgICAgIEVORFxuICAgICAgICAgICAgICArIG51bGxkYXRhd2lkdGggKyBtYXhhbGlnbiAtIENBU0UgLS0gQWRkIHBhZGRpbmcgdG8gdGhlIGRhdGEgdG8gYWxpZ24gb24gTUFYQUxJR05cbiAgICAgICAgICAgICAgICAgIFdIRU4gbnVsbGRhdGF3aWR0aCA9IDAgVEhFTiAwXG4gICAgICAgICAgICAgICAgICBXSEVOIG51bGxkYXRhd2lkdGg6OmludGVnZXIlbWF4YWxpZ24gPSAwIFRIRU4gbWF4YWxpZ25cbiAgICAgICAgICAgICAgICAgIEVMU0UgbnVsbGRhdGF3aWR0aDo6aW50ZWdlciVtYXhhbGlnblxuICAgICAgICAgICAgICAgIEVORFxuICAgICAgICAgICAgKTo6bnVtZXJpYyBBUyBudWxsZGF0YWhkcndpZHRoLCBwYWdlaGRyLCBwYWdlb3BxZGF0YSwgaXNfbmFcbiAgICAgICAgICAgIC0tICwgaW5kZXhfdHVwbGVfaGRyX2JtLCBudWxsZGF0YXdpZHRoIC0tIChERUJVRyBJTkZPKVxuICAgICAgRlJPTSAoXG4gICAgICAgICAgU0VMRUNUIG4ubnNwbmFtZSwgaS50YmxuYW1lLCBpLmlkeG5hbWUsIGkucmVsdHVwbGVzLCBpLnJlbHBhZ2VzLFxuICAgICAgICAgICAgICBpLmlkeG9pZCwgaS5maWxsZmFjdG9yLCBjdXJyZW50X3NldHRpbmcoJ2Jsb2NrX3NpemUnKTo6bnVtZXJpYyBBUyBicyxcbiAgICAgICAgICAgICAgQ0FTRSAtLSBNQVhBTElHTjogNCBvbiAzMmJpdHMsIDggb24gNjRiaXRzIChhbmQgbWluZ3czMiA/KVxuICAgICAgICAgICAgICAgIFdIRU4gdmVyc2lvbigpIH4gJ21pbmd3MzInIE9SIHZlcnNpb24oKSB+ICc2NC1iaXR8eDg2XzY0fHBwYzY0fGlhNjR8YW1kNjQnIFRIRU4gOFxuICAgICAgICAgICAgICAgIEVMU0UgNFxuICAgICAgICAgICAgICBFTkQgQVMgbWF4YWxpZ24sXG4gICAgICAgICAgICAgIC8qIHBlciBwYWdlIGhlYWRlciwgZml4ZWQgc2l6ZTogMjAgZm9yIDcuWCwgMjQgZm9yIG90aGVycyAqL1xuICAgICAgICAgICAgICAyNCBBUyBwYWdlaGRyLFxuICAgICAgICAgICAgICAvKiBwZXIgcGFnZSBidHJlZSBvcGFxdWUgZGF0YSAqL1xuICAgICAgICAgICAgICAxNiBBUyBwYWdlb3BxZGF0YSxcbiAgICAgICAgICAgICAgLyogcGVyIHR1cGxlIGhlYWRlcjogYWRkIEluZGV4QXR0cmlidXRlQml0TWFwRGF0YSBpZiBzb21lIGNvbHMgYXJlIG51bGwtYWJsZSAqL1xuICAgICAgICAgICAgICBDQVNFIFdIRU4gbWF4KGNvYWxlc2NlKHMubnVsbF9mcmFjLDApKSA9IDBcbiAgICAgICAgICAgICAgICAgIFRIRU4gOCAtLSBJbmRleFR1cGxlRGF0YSBzaXplXG4gICAgICAgICAgICAgICAgICBFTFNFIDggKyAoKCAzMiArIDggLSAxICkgLyA4KSAtLSBJbmRleFR1cGxlRGF0YSBzaXplICsgSW5kZXhBdHRyaWJ1dGVCaXRNYXBEYXRhIHNpemUgKCBtYXggbnVtIGZpbGVkIHBlciBpbmRleCArIDggLSAxIC84KVxuICAgICAgICAgICAgICBFTkQgQVMgaW5kZXhfdHVwbGVfaGRyX2JtLFxuICAgICAgICAgICAgICAvKiBkYXRhIGxlbjogd2UgcmVtb3ZlIG51bGwgdmFsdWVzIHNhdmUgc3BhY2UgdXNpbmcgaXQgZnJhY3Rpb25uYWwgcGFydCBmcm9tIHN0YXRzICovXG4gICAgICAgICAgICAgIHN1bSggKDEtY29hbGVzY2Uocy5udWxsX2ZyYWMsIDApKSAqIGNvYWxlc2NlKHMuYXZnX3dpZHRoLCAxMDI0KSkgQVMgbnVsbGRhdGF3aWR0aCxcbiAgICAgICAgICAgICAgbWF4KCBDQVNFIFdIRU4gaS5hdHR0eXBpZCA9ICdwZ19jYXRhbG9nLm5hbWUnOjpyZWd0eXBlIFRIRU4gMSBFTFNFIDAgRU5EICkgPiAwIEFTIGlzX25hXG4gICAgICAgICAgRlJPTSAoXG4gICAgICAgICAgICAgIFNFTEVDVCBjdC5yZWxuYW1lIEFTIHRibG5hbWUsIGN0LnJlbG5hbWVzcGFjZSwgaWMuaWR4bmFtZSwgaWMuYXR0cG9zLCBpYy5pbmRrZXksIGljLmluZGtleVtpYy5hdHRwb3NdLCBpYy5yZWx0dXBsZXMsIGljLnJlbHBhZ2VzLCBpYy50YmxvaWQsIGljLmlkeG9pZCwgaWMuZmlsbGZhY3RvcixcbiAgICAgICAgICAgICAgICAgIGNvYWxlc2NlKGExLmF0dG51bSwgYTIuYXR0bnVtKSBBUyBhdHRudW0sIGNvYWxlc2NlKGExLmF0dG5hbWUsIGEyLmF0dG5hbWUpIEFTIGF0dG5hbWUsIGNvYWxlc2NlKGExLmF0dHR5cGlkLCBhMi5hdHR0eXBpZCkgQVMgYXR0dHlwaWQsXG4gICAgICAgICAgICAgICAgICBDQVNFIFdIRU4gYTEuYXR0bnVtIElTIE5VTExcbiAgICAgICAgICAgICAgICAgIFRIRU4gaWMuaWR4bmFtZVxuICAgICAgICAgICAgICAgICAgRUxTRSBjdC5yZWxuYW1lXG4gICAgICAgICAgICAgICAgICBFTkQgQVMgYXR0cmVsbmFtZVxuICAgICAgICAgICAgICBGUk9NIChcbiAgICAgICAgICAgICAgICAgIFNFTEVDVCBpZHhuYW1lLCByZWx0dXBsZXMsIHJlbHBhZ2VzLCB0YmxvaWQsIGlkeG9pZCwgZmlsbGZhY3RvciwgaW5ka2V5LFxuICAgICAgICAgICAgICAgICAgICAgIHBnX2NhdGFsb2cuZ2VuZXJhdGVfc2VyaWVzKDEsaW5kbmF0dHMpIEFTIGF0dHBvc1xuICAgICAgICAgICAgICAgICAgRlJPTSAoXG4gICAgICAgICAgICAgICAgICAgICAgU0VMRUNUIGNpLnJlbG5hbWUgQVMgaWR4bmFtZSwgY2kucmVsdHVwbGVzLCBjaS5yZWxwYWdlcywgaS5pbmRyZWxpZCBBUyB0YmxvaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGkuaW5kZXhyZWxpZCBBUyBpZHhvaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvYWxlc2NlKHN1YnN0cmluZyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5X3RvX3N0cmluZyhjaS5yZWxvcHRpb25zLCAnICcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tICdmaWxsZmFjdG9yPShbMC05XSspJyk6OnNtYWxsaW50LCA5MCkgQVMgZmlsbGZhY3RvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaS5pbmRuYXR0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcGdfY2F0YWxvZy5zdHJpbmdfdG9fYXJyYXkocGdfY2F0YWxvZy50ZXh0aW4oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZ19jYXRhbG9nLmludDJ2ZWN0b3JvdXQoaS5pbmRrZXkpKSwnICcpOjppbnRbXSBBUyBpbmRrZXlcbiAgICAgICAgICAgICAgICAgICAgICBGUk9NIHBnX2NhdGFsb2cucGdfaW5kZXggaVxuICAgICAgICAgICAgICAgICAgICAgIEpPSU4gcGdfY2F0YWxvZy5wZ19jbGFzcyBjaSBPTiBjaS5vaWQgPSBpLmluZGV4cmVsaWRcbiAgICAgICAgICAgICAgICAgICAgICBXSEVSRSBjaS5yZWxhbT0oU0VMRUNUIG9pZCBGUk9NIHBnX2FtIFdIRVJFIGFtbmFtZSA9ICdidHJlZScpXG4gICAgICAgICAgICAgICAgICAgICAgQU5EIGNpLnJlbHBhZ2VzID4gMFxuICAgICAgICAgICAgICAgICAgKSBBUyBpZHhfZGF0YVxuICAgICAgICAgICAgICApIEFTIGljXG4gICAgICAgICAgICAgIEpPSU4gcGdfY2F0YWxvZy5wZ19jbGFzcyBjdCBPTiBjdC5vaWQgPSBpYy50YmxvaWRcbiAgICAgICAgICAgICAgTEVGVCBKT0lOIHBnX2NhdGFsb2cucGdfYXR0cmlidXRlIGExIE9OXG4gICAgICAgICAgICAgICAgICBpYy5pbmRrZXlbaWMuYXR0cG9zXSA8PiAwXG4gICAgICAgICAgICAgICAgICBBTkQgYTEuYXR0cmVsaWQgPSBpYy50YmxvaWRcbiAgICAgICAgICAgICAgICAgIEFORCBhMS5hdHRudW0gPSBpYy5pbmRrZXlbaWMuYXR0cG9zXVxuICAgICAgICAgICAgICBMRUZUIEpPSU4gcGdfY2F0YWxvZy5wZ19hdHRyaWJ1dGUgYTIgT05cbiAgICAgICAgICAgICAgICAgIGljLmluZGtleVtpYy5hdHRwb3NdID0gMFxuICAgICAgICAgICAgICAgICAgQU5EIGEyLmF0dHJlbGlkID0gaWMuaWR4b2lkXG4gICAgICAgICAgICAgICAgICBBTkQgYTIuYXR0bnVtID0gaWMuYXR0cG9zXG4gICAgICAgICAgICApIGlcbiAgICAgICAgICAgIEpPSU4gcGdfY2F0YWxvZy5wZ19uYW1lc3BhY2UgbiBPTiBuLm9pZCA9IGkucmVsbmFtZXNwYWNlXG4gICAgICAgICAgICBKT0lOIHBnX2NhdGFsb2cucGdfc3RhdHMgcyBPTiBzLnNjaGVtYW5hbWUgPSBuLm5zcG5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQU5EIHMudGFibGVuYW1lID0gaS5hdHRyZWxuYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFORCBzLmF0dG5hbWUgPSBpLmF0dG5hbWVcbiAgICAgICAgICAgIEdST1VQIEJZIDEsMiwzLDQsNSw2LDcsOCw5LDEwLDExXG4gICAgICApIEFTIHJvd3NfZGF0YV9zdGF0c1xuICApIEFTIHJvd3NfaGRyX3BkZ19zdGF0c1xuKSBBUyByZWxhdGlvbl9zdGF0c1xuV0hFUkVcbiAgICBuc3BuYW1lIE5PVCBJTiAoJ2luZm9ybWF0aW9uX3NjaGVtYScsICdwZ19jYXRhbG9nJykgQU5EXG4gICAgMTAwLjAgKiAocmVscGFnZXMtZXN0X3BhZ2VzKTo6ZmxvYXQgLyByZWxwYWdlczo6ZmxvYXQgPiAwXG5PUkRFUiBCWSBleHRyYV9wY3QgREVTQzsiLCJyZXN1bHRfdmFyaWFibGUiOiJpbmRleF9ibG9hdCIsInRpbWVvdXQiOm51bGx9","chunks":null,"kind":"Elixir.KinoDB.SQLCell","livebook_object":"smart_cell"} -->

```elixir
index_bloat =
  Postgrex.query!(
    conn,
    """
    SELECT current_database(), nspname AS schemaname, tblname, idxname, bs*(relpages)::bigint AS real_size,
      bs*(relpages-est_pages)::bigint AS extra_size,
      100.0 * (relpages-est_pages)::float / relpages::float AS extra_pct,
      fillfactor,
      CASE WHEN relpages > est_pages_ff
        THEN bs*(relpages-est_pages_ff)
        ELSE 0
      END AS bloat_size,
      (100 * (relpages-est_pages_ff)::float) / relpages::float AS bloat_pct,
      is_na
      -- , 100-(pst).avg_leaf_density AS pst_avg_bloat, est_pages, index_tuple_hdr_bm, maxalign, pagehdr, nulldatawidth, nulldatahdrwidth, reltuples, relpages -- (DEBUG INFO)
    FROM (
      SELECT coalesce(1 +
             ceil(reltuples/floor((bs-pageopqdata-pagehdr)/(4+nulldatahdrwidth)::float)), 0 -- ItemIdData size + computed avg size of a tuple (nulldatahdrwidth)
          ) AS est_pages,
          coalesce(1 +
             ceil(reltuples/floor((bs-pageopqdata-pagehdr)*fillfactor/(100*(4+nulldatahdrwidth)::float))), 0
          ) AS est_pages_ff,
          bs, nspname, tblname, idxname, relpages, fillfactor, is_na
          -- , pgstatindex(idxoid) AS pst, index_tuple_hdr_bm, maxalign, pagehdr, nulldatawidth, nulldatahdrwidth, reltuples -- (DEBUG INFO)
      FROM (
          SELECT maxalign, bs, nspname, tblname, idxname, reltuples, relpages, idxoid, fillfactor,
                ( index_tuple_hdr_bm +
                    maxalign - CASE -- Add padding to the index tuple header to align on MAXALIGN
                      WHEN index_tuple_hdr_bm%maxalign = 0 THEN maxalign
                      ELSE index_tuple_hdr_bm%maxalign
                    END
                  + nulldatawidth + maxalign - CASE -- Add padding to the data to align on MAXALIGN
                      WHEN nulldatawidth = 0 THEN 0
                      WHEN nulldatawidth::integer%maxalign = 0 THEN maxalign
                      ELSE nulldatawidth::integer%maxalign
                    END
                )::numeric AS nulldatahdrwidth, pagehdr, pageopqdata, is_na
                -- , index_tuple_hdr_bm, nulldatawidth -- (DEBUG INFO)
          FROM (
              SELECT n.nspname, i.tblname, i.idxname, i.reltuples, i.relpages,
                  i.idxoid, i.fillfactor, current_setting('block_size')::numeric AS bs,
                  CASE -- MAXALIGN: 4 on 32bits, 8 on 64bits (and mingw32 ?)
                    WHEN version() ~ 'mingw32' OR version() ~ '64-bit|x86_64|ppc64|ia64|amd64' THEN 8
                    ELSE 4
                  END AS maxalign,
                  /* per page header, fixed size: 20 for 7.X, 24 for others */
                  24 AS pagehdr,
                  /* per page btree opaque data */
                  16 AS pageopqdata,
                  /* per tuple header: add IndexAttributeBitMapData if some cols are null-able */
                  CASE WHEN max(coalesce(s.null_frac,0)) = 0
                      THEN 8 -- IndexTupleData size
                      ELSE 8 + (( 32 + 8 - 1 ) / 8) -- IndexTupleData size + IndexAttributeBitMapData size ( max num filed per index + 8 - 1 /8)
                  END AS index_tuple_hdr_bm,
                  /* data len: we remove null values save space using it fractionnal part from stats */
                  sum( (1-coalesce(s.null_frac, 0)) * coalesce(s.avg_width, 1024)) AS nulldatawidth,
                  max( CASE WHEN i.atttypid = 'pg_catalog.name'::regtype THEN 1 ELSE 0 END ) > 0 AS is_na
              FROM (
                  SELECT ct.relname AS tblname, ct.relnamespace, ic.idxname, ic.attpos, ic.indkey, ic.indkey[ic.attpos], ic.reltuples, ic.relpages, ic.tbloid, ic.idxoid, ic.fillfactor,
                      coalesce(a1.attnum, a2.attnum) AS attnum, coalesce(a1.attname, a2.attname) AS attname, coalesce(a1.atttypid, a2.atttypid) AS atttypid,
                      CASE WHEN a1.attnum IS NULL
                      THEN ic.idxname
                      ELSE ct.relname
                      END AS attrelname
                  FROM (
                      SELECT idxname, reltuples, relpages, tbloid, idxoid, fillfactor, indkey,
                          pg_catalog.generate_series(1,indnatts) AS attpos
                      FROM (
                          SELECT ci.relname AS idxname, ci.reltuples, ci.relpages, i.indrelid AS tbloid,
                              i.indexrelid AS idxoid,
                              coalesce(substring(
                                  array_to_string(ci.reloptions, ' ')
                                  from 'fillfactor=([0-9]+)')::smallint, 90) AS fillfactor,
                              i.indnatts,
                              pg_catalog.string_to_array(pg_catalog.textin(
                                  pg_catalog.int2vectorout(i.indkey)),' ')::int[] AS indkey
                          FROM pg_catalog.pg_index i
                          JOIN pg_catalog.pg_class ci ON ci.oid = i.indexrelid
                          WHERE ci.relam=(SELECT oid FROM pg_am WHERE amname = 'btree')
                          AND ci.relpages > 0
                      ) AS idx_data
                  ) AS ic
                  JOIN pg_catalog.pg_class ct ON ct.oid = ic.tbloid
                  LEFT JOIN pg_catalog.pg_attribute a1 ON
                      ic.indkey[ic.attpos] <> 0
                      AND a1.attrelid = ic.tbloid
                      AND a1.attnum = ic.indkey[ic.attpos]
                  LEFT JOIN pg_catalog.pg_attribute a2 ON
                      ic.indkey[ic.attpos] = 0
                      AND a2.attrelid = ic.idxoid
                      AND a2.attnum = ic.attpos
                ) i
                JOIN pg_catalog.pg_namespace n ON n.oid = i.relnamespace
                JOIN pg_catalog.pg_stats s ON s.schemaname = n.nspname
                                          AND s.tablename = i.attrelname
                                          AND s.attname = i.attname
                GROUP BY 1,2,3,4,5,6,7,8,9,10,11
          ) AS rows_data_stats
      ) AS rows_hdr_pdg_stats
    ) AS relation_stats
    WHERE
        nspname NOT IN ('information_schema', 'pg_catalog') AND
        100.0 * (relpages-est_pages)::float / relpages::float > 0
    ORDER BY extra_pct DESC;
    """,
    []
  )
```

<!-- livebook:{"attrs":"eyJjaGFydF90aXRsZSI6IkluZGV4IEJsb2F0IiwiaGVpZ2h0IjpudWxsLCJsYXllcnMiOlt7ImFjdGl2ZSI6dHJ1ZSwiY2hhcnRfdHlwZSI6ImJhciIsImNvbG9yX2ZpZWxkIjpudWxsLCJjb2xvcl9maWVsZF9hZ2dyZWdhdGUiOm51bGwsImNvbG9yX2ZpZWxkX2JpbiI6bnVsbCwiY29sb3JfZmllbGRfc2NhbGVfc2NoZW1lIjpudWxsLCJjb2xvcl9maWVsZF90eXBlIjpudWxsLCJkYXRhX3ZhcmlhYmxlIjoiaW5kZXhfYmxvYXQiLCJnZW9kYXRhX2NvbG9yIjoiYmx1ZSIsImxhdGl0dWRlX2ZpZWxkIjpudWxsLCJsb25naXR1ZGVfZmllbGQiOm51bGwsInhfZmllbGQiOiJpZHhuYW1lIiwieF9maWVsZF9hZ2dyZWdhdGUiOm51bGwsInhfZmllbGRfYmluIjpudWxsLCJ4X2ZpZWxkX3NjYWxlX3R5cGUiOm51bGwsInhfZmllbGRfdHlwZSI6Im5vbWluYWwiLCJ5X2ZpZWxkIjoiYmxvYXRfcGN0IiwieV9maWVsZF9hZ2dyZWdhdGUiOm51bGwsInlfZmllbGRfYmluIjpudWxsLCJ5X2ZpZWxkX3NjYWxlX3R5cGUiOm51bGwsInlfZmllbGRfdHlwZSI6InF1YW50aXRhdGl2ZSJ9XSwidmxfYWxpYXMiOiJFbGl4aXIuVmVnYUxpdGUiLCJ3aWR0aCI6NzAwfQ","chunks":null,"kind":"Elixir.KinoVegaLite.ChartCell","livebook_object":"smart_cell"} -->

```elixir
VegaLite.new(width: 700, title: "Index Bloat")
|> VegaLite.data_from_values(index_bloat, only: ["idxname", "bloat_pct"])
|> VegaLite.mark(:bar)
|> VegaLite.encode_field(:x, "idxname", type: :nominal)
|> VegaLite.encode_field(:y, "bloat_pct", type: :quantitative)
```

### Index Bloat

```elixir
# IO.inspect(index_bloat)
IO.puts(
  "-- Do not run these unless you know there won't be side effects.  Make sure your server has been running long enough to evaluate index usage."
)

IO.puts("-- Uncomment and run the following to clean up indexe free space.")

for row <- index_bloat.rows do
  [_db, schema, _table, index, _, _, idx_pct, _, _, _, _] = row

  if idx_pct > 10 do
    IO.puts("-- REINDEX INDEX CONCURRENTLY #{schema}.#{index};")
  end
end
```

## Relation Sizes

### Relation sizes (in one query)

If this an OLTP database this is all expected to fit in RAM buffers.
If this is an OLAP database it is not required, but keep an eye on disk IO if you see performance worse than expected.
If this is a pass through db then basically the OLAP rules apply.

<!-- livebook:{"attrs":"eyJjYWNoZV9xdWVyeSI6dHJ1ZSwiY29ubmVjdGlvbiI6eyJ0eXBlIjoicG9zdGdyZXMiLCJ2YXJpYWJsZSI6ImNvbm4ifSwicXVlcnkiOiJXSVRIIGRiX3NpemUgQVMgKFxuICAgIFNFTEVDVCBjdXJyZW50X2RhdGFiYXNlKCkgQVMgcmVsbmFtZSxcbiAgICAgICAgICAgcGdfc2l6ZV9wcmV0dHkocGdfZGF0YWJhc2Vfc2l6ZShjdXJyZW50X2RhdGFiYXNlKCkpKSBBUyByZWxzaXplXG4pLFxudG90YWxfdGFibGVfc2l6ZSBBUyAoXG4gICAgU0VMRUNUXG4gICAgICAgIHBnX3NpemVfcHJldHR5KHN1bShwZ190YWJsZV9zaXplKHNjaGVtYW5hbWUgfHwgJy4nIHx8IHJlbG5hbWUpKSkgQVMgdGFibGVodW1hbnNpemVcbiAgICBGUk9NIHBnX3N0YXRfdXNlcl90YWJsZXNcbiksXG50YWJsZV9zaXplIEFTIChcbiAgICBTRUxFQ1RcbiAgICAgICAgc2NoZW1hbmFtZSB8fCAnLicgfHwgcmVsbmFtZSBBUyB0YWJsZW5hbWUsXG4gICAgICAgIHBnX3NpemVfcHJldHR5KHBnX3RhYmxlX3NpemUoc2NoZW1hbmFtZSB8fCAnLicgfHwgcmVsbmFtZSkpIEFTIHRhYmxlaHVtYW5zaXplLFxuICAgICAgICBwZ190YWJsZV9zaXplKHNjaGVtYW5hbWUgfHwgJy4nIHx8IHJlbG5hbWUpIEFTIHRhYmxlc2l6ZVxuICAgIEZST00gcGdfc3RhdF91c2VyX3RhYmxlc1xuICAgIE9SREVSIEJZXG4gICAgICAgIHRhYmxlc2l6ZSBERVNDXG4pLFxudG90YWxfaW5kZXhfc2l6ZSBBUyAoXG4gICAgU0VMRUNUXG4gICAgICAgIHBnX3NpemVfcHJldHR5KHN1bShwZ19pbmRleGVzX3NpemUoc2NoZW1hbmFtZSB8fCAnLicgfHwgcmVsbmFtZSkpKSBBUyBpbmRleGh1bWFuc2l6ZVxuICAgIEZST00gcGdfc3RhdF91c2VyX2luZGV4ZXNcbiksXG5pbmRleF9zaXplIEFTIChcbiAgICBTRUxFQ1RcbiAgICAgICAgc2NoZW1hbmFtZSB8fCAnLicgfHwgcmVsbmFtZSB8fCAnLicgfHwgaW5kZXhyZWxuYW1lIEFTIGluZGV4bmFtZSxcbiAgICAgICAgcGdfaW5kZXhlc19zaXplKHNjaGVtYW5hbWUgfHwgJy4nIHx8IHJlbG5hbWUpIEFTIGluZGV4c2l6ZSxcbiAgICAgICAgcGdfc2l6ZV9wcmV0dHkocGdfaW5kZXhlc19zaXplKHNjaGVtYW5hbWUgfHwgJy4nIHx8IHJlbG5hbWUpKSBBUyBpbmRleGh1bWFuc2l6ZVxuICAgIEZST00gcGdfc3RhdF91c2VyX2luZGV4ZXNcbiAgICBPUkRFUiBCWVxuICAgICAgICBpbmRleHNpemUgREVTQ1xuKVxuU0VMRUNUICdEYXRhYmFzZScgQVMgcmVsYXRpb24sICdTaXplJyBBUyBzaXplXG5VTklPTiBBTExcblNFTEVDVCByZWxuYW1lIEFTIHJlbGF0aW9uLCByZWxzaXplIEFTIHNpemUgRlJPTSBkYl9zaXplXG5VTklPTiBBTExcblNFTEVDVCAnLS0tLS0tLS0tJyAsICctLS0tLS0tLS0nXG5VTklPTiBBTExcblNFTEVDVCAnVG90YWwgVGFibGUnIEFTIHJlbGF0aW9uLCAnU2l6ZScgQVMgc2l6ZVxuVU5JT04gQUxMXG5TRUxFQ1QgJ0FsbCBUYWJsZXMnLCB0YWJsZWh1bWFuc2l6ZSBGUk9NIHRvdGFsX3RhYmxlX3NpemVcblVOSU9OIEFMTFxuU0VMRUNUICctLS0tLS0tLS0nICwgJy0tLS0tLS0tLSdcblVOSU9OIEFMTFxuU0VMRUNUICdUYWJsZScgQVMgcmVsYXRpb24sICdTaXplJyBBUyBzaXplXG5VTklPTiBBTExcblNFTEVDVCB0YWJsZW5hbWUgQVMgcmVsYXRpb24sIHRhYmxlaHVtYW5zaXplIEFTIHNpemUgRlJPTSB0YWJsZV9zaXplXG5VTklPTiBBTExcblNFTEVDVCAnLS0tLS0tLS0tJyAsICctLS0tLS0tLS0nXG5VTklPTiBBTExcblNFTEVDVCAnVG90YWwgSW5kZXgnIEFTIHJlbGF0aW9uLCAnU2l6ZScgQVMgc2l6ZVxuVU5JT04gQUxMXG5TRUxFQ1QgJ0FsbCBJbmRleGVzJywgaW5kZXhodW1hbnNpemUgRlJPTSB0b3RhbF9pbmRleF9zaXplXG5VTklPTiBBTExcblNFTEVDVCAnLS0tLS0tLS0tJyAsICctLS0tLS0tLS0nXG5VTklPTiBBTExcblNFTEVDVCAnSW5kZXgnIEFTIHJlbGF0aW9uLCAnU2l6ZScgQVMgc2l6ZVxuVU5JT04gQUxMXG5TRUxFQ1QgaW5kZXhuYW1lIEFTIHJlbGF0aW9uLCBpbmRleGh1bWFuc2l6ZSBBUyBzaXplIEZST00gaW5kZXhfc2l6ZTsiLCJyZXN1bHRfdmFyaWFibGUiOiJyZWxhdGlvbl9zaXplIiwidGltZW91dCI6bnVsbH0","chunks":null,"kind":"Elixir.KinoDB.SQLCell","livebook_object":"smart_cell"} -->

```elixir
relation_size =
  Postgrex.query!(
    conn,
    """
    WITH db_size AS (
        SELECT current_database() AS relname,
               pg_size_pretty(pg_database_size(current_database())) AS relsize
    ),
    total_table_size AS (
        SELECT
            pg_size_pretty(sum(pg_table_size(schemaname || '.' || relname))) AS tablehumansize
        FROM pg_stat_user_tables
    ),
    table_size AS (
        SELECT
            schemaname || '.' || relname AS tablename,
            pg_size_pretty(pg_table_size(schemaname || '.' || relname)) AS tablehumansize,
            pg_table_size(schemaname || '.' || relname) AS tablesize
        FROM pg_stat_user_tables
        ORDER BY
            tablesize DESC
    ),
    total_index_size AS (
        SELECT
            pg_size_pretty(sum(pg_indexes_size(schemaname || '.' || relname))) AS indexhumansize
        FROM pg_stat_user_indexes
    ),
    index_size AS (
        SELECT
            schemaname || '.' || relname || '.' || indexrelname AS indexname,
            pg_indexes_size(schemaname || '.' || relname) AS indexsize,
            pg_size_pretty(pg_indexes_size(schemaname || '.' || relname)) AS indexhumansize
        FROM pg_stat_user_indexes
        ORDER BY
            indexsize DESC
    )
    SELECT 'Database' AS relation, 'Size' AS size
    UNION ALL
    SELECT relname AS relation, relsize AS size FROM db_size
    UNION ALL
    SELECT '---------' , '---------'
    UNION ALL
    SELECT 'Total Table' AS relation, 'Size' AS size
    UNION ALL
    SELECT 'All Tables', tablehumansize FROM total_table_size
    UNION ALL
    SELECT '---------' , '---------'
    UNION ALL
    SELECT 'Table' AS relation, 'Size' AS size
    UNION ALL
    SELECT tablename AS relation, tablehumansize AS size FROM table_size
    UNION ALL
    SELECT '---------' , '---------'
    UNION ALL
    SELECT 'Total Index' AS relation, 'Size' AS size
    UNION ALL
    SELECT 'All Indexes', indexhumansize FROM total_index_size
    UNION ALL
    SELECT '---------' , '---------'
    UNION ALL
    SELECT 'Index' AS relation, 'Size' AS size
    UNION ALL
    SELECT indexname AS relation, indexhumansize AS size FROM index_size;
    """,
    []
  )
```

### Database Sizes

Optionally, you can just look at database sizes.  This is better if multiple databases are used.  Use the above query per database if you wish to break down each.  See comments above on DB types and whether these should all fit in memory.

<!-- livebook:{"attrs":"eyJjYWNoZV9xdWVyeSI6dHJ1ZSwiY29ubmVjdGlvbiI6eyJ0eXBlIjoicG9zdGdyZXMiLCJ2YXJpYWJsZSI6ImNvbm4ifSwicXVlcnkiOiJTRUxFQ1RcbiBkYXRuYW1lLCBcbiBwZ19zaXplX3ByZXR0eShwZ19kYXRhYmFzZV9zaXplKGRhdG5hbWUpKSBBUyBzaXplLCBcbiBwZ19kYXRhYmFzZV9zaXplKGRhdG5hbWUpIEFTIGFjdHVhbCBcbkZST00gXG4gcGdfc3RhdF9kYXRhYmFzZSBcbldIRVJFIFxuIGRhdG5hbWUgSVMgTk9UIE5VTEwgQU5EXG4gZGF0bmFtZSBOT1QgSU4gKCdwb3N0Z3JlcycsICd0ZW1wbGF0ZTAnLCAndGVtcGxhdGUxJykiLCJyZXN1bHRfdmFyaWFibGUiOiJkYl9zaXplcyIsInRpbWVvdXQiOm51bGx9","chunks":null,"kind":"Elixir.KinoDB.SQLCell","livebook_object":"smart_cell"} -->

```elixir
db_sizes =
  Postgrex.query!(
    conn,
    """
    SELECT
     datname, 
     pg_size_pretty(pg_database_size(datname)) AS size, 
     pg_database_size(datname) AS actual 
    FROM 
     pg_stat_database 
    WHERE 
     datname IS NOT NULL AND
     datname NOT IN ('postgres', 'template0', 'template1')
    """,
    []
  )
```

<!-- livebook:{"attrs":"eyJjaGFydF90aXRsZSI6IkRhdGFiYXNlIFNpemVzIiwiaGVpZ2h0IjpudWxsLCJsYXllcnMiOlt7ImFjdGl2ZSI6dHJ1ZSwiY2hhcnRfdHlwZSI6ImJhciIsImNvbG9yX2ZpZWxkIjpudWxsLCJjb2xvcl9maWVsZF9hZ2dyZWdhdGUiOm51bGwsImNvbG9yX2ZpZWxkX2JpbiI6bnVsbCwiY29sb3JfZmllbGRfc2NhbGVfc2NoZW1lIjpudWxsLCJjb2xvcl9maWVsZF90eXBlIjpudWxsLCJkYXRhX3ZhcmlhYmxlIjoiZGJfc2l6ZXMiLCJnZW9kYXRhX2NvbG9yIjoiYmx1ZSIsImxhdGl0dWRlX2ZpZWxkIjpudWxsLCJsb25naXR1ZGVfZmllbGQiOm51bGwsInhfZmllbGQiOiJkYXRuYW1lIiwieF9maWVsZF9hZ2dyZWdhdGUiOm51bGwsInhfZmllbGRfYmluIjpudWxsLCJ4X2ZpZWxkX3NjYWxlX3R5cGUiOm51bGwsInhfZmllbGRfdHlwZSI6Im5vbWluYWwiLCJ5X2ZpZWxkIjoiYWN0dWFsIiwieV9maWVsZF9hZ2dyZWdhdGUiOm51bGwsInlfZmllbGRfYmluIjpudWxsLCJ5X2ZpZWxkX3NjYWxlX3R5cGUiOm51bGwsInlfZmllbGRfdHlwZSI6InF1YW50aXRhdGl2ZSJ9XSwidmxfYWxpYXMiOiJFbGl4aXIuVmVnYUxpdGUiLCJ3aWR0aCI6NjAwfQ","chunks":null,"kind":"Elixir.KinoVegaLite.ChartCell","livebook_object":"smart_cell"} -->

```elixir
VegaLite.new(width: 600, title: "Database Sizes")
|> VegaLite.data_from_values(db_sizes, only: ["datname", "actual"])
|> VegaLite.mark(:bar)
|> VegaLite.encode_field(:x, "datname", type: :nominal)
|> VegaLite.encode_field(:y, "actual", type: :quantitative)
```

### Total Database Size - All databases

<!-- livebook:{"attrs":"eyJjYWNoZV9xdWVyeSI6dHJ1ZSwiY29ubmVjdGlvbiI6eyJ0eXBlIjoicG9zdGdyZXMiLCJ2YXJpYWJsZSI6ImNvbm4ifSwicXVlcnkiOiJTRUxFQ1QgXG4gJ1RPVEFMJyBhcyB0b3RhbCwgXG4gcGdfc2l6ZV9wcmV0dHkoc3VtKHBnX2RhdGFiYXNlX3NpemUoZGF0bmFtZSkpKSBBUyBzaXplLCBcbiBzdW0ocGdfZGF0YWJhc2Vfc2l6ZShkYXRuYW1lKSkgQVMgYWN0dWFsIFxuRlJPTVxuIHBnX3N0YXRfZGF0YWJhc2U7IiwicmVzdWx0X3ZhcmlhYmxlIjoidG90YWxfZGJfc2l6ZSIsInRpbWVvdXQiOm51bGx9","chunks":null,"kind":"Elixir.KinoDB.SQLCell","livebook_object":"smart_cell"} -->

```elixir
total_db_size =
  Postgrex.query!(
    conn,
    """
    SELECT 
     'TOTAL' as total, 
     pg_size_pretty(sum(pg_database_size(datname))) AS size, 
     sum(pg_database_size(datname)) AS actual 
    FROM
     pg_stat_database;
    """,
    []
  )
```

### Will my database fit in available buffers?

This query looks at the size of all objects in your database and compares it to available buffers.  If it is an OLTP database then all objects should fit.  If you include archiving or logging in the same database reconsider, but in that case all "hot" frequently queried data needs to fit in memory.  If it's OLAP then memory allocation should meet the query latency expectations of the end user.  If people think your OLAP db is too slow, add memory.

#### Note: Third column represents the memory / buffer percentage.

<!-- livebook:{"attrs":"eyJjYWNoZV9xdWVyeSI6dHJ1ZSwiY29ubmVjdGlvbiI6eyJ0eXBlIjoicG9zdGdyZXMiLCJ2YXJpYWJsZSI6ImNvbm4ifSwicXVlcnkiOiJXSVRIIHRvdGFsX2RiX3NpemUgQVMgKFxuIFNFTEVDVFxuICBzdW0ocGdfZGF0YWJhc2Vfc2l6ZShkYXRuYW1lKSk6OmZsb2F0IEFTIGRiX3NpemVcbiBGUk9NXG4gIHBnX3N0YXRfZGF0YWJhc2VcbiksXG50b3RhbF9idWZmZXJfc2l6ZSBBUyAoXG4gU0VMRUNUXG4gIChyZXBsYWNlKHVuaXQsICdrQicsICcnKTo6aW50ICogMTAyNCAqIHNldHRpbmc6OmludCk6OmZsb2F0IEFTIGJ1ZmZlcl9zaXplXG4gRlJPTVxuICBwZ19zZXR0aW5ncyBcbiBXSEVSRVxuICBuYW1lID0gJ3NoYXJlZF9idWZmZXJzJ1xuKVxuU0VMRUNUXG4gdG90YWxfZGJfc2l6ZS5kYl9zaXplLFxuIHRvdGFsX2J1ZmZlcl9zaXplLmJ1ZmZlcl9zaXplLFxuICh0b3RhbF9kYl9zaXplLmRiX3NpemUgKyAxLjApIC8gKHRvdGFsX2J1ZmZlcl9zaXplLmJ1ZmZlcl9zaXplICsgMS4wKSAqIDEwMC4wIEFTIGRhdGFfdnNfYnVmZmVyX3BlcmNlbnRhZ2VcbkZST01cbiB0b3RhbF9kYl9zaXplXG5KT0lOIHRvdGFsX2J1ZmZlcl9zaXplIE9OIDEgPSAxOyIsInJlc3VsdF92YXJpYWJsZSI6ImRhdGFfdnNfYnVmZmVyIiwidGltZW91dCI6bnVsbH0","chunks":null,"kind":"Elixir.KinoDB.SQLCell","livebook_object":"smart_cell"} -->

```elixir
data_vs_buffer =
  Postgrex.query!(
    conn,
    """
    WITH total_db_size AS (
     SELECT
      sum(pg_database_size(datname))::float AS db_size
     FROM
      pg_stat_database
    ),
    total_buffer_size AS (
     SELECT
      (replace(unit, 'kB', '')::int * 1024 * setting::int)::float AS buffer_size
     FROM
      pg_settings 
     WHERE
      name = 'shared_buffers'
    )
    SELECT
     total_db_size.db_size,
     total_buffer_size.buffer_size,
     (total_db_size.db_size + 1.0) / (total_buffer_size.buffer_size + 1.0) * 100.0 AS data_vs_buffer_percentage
    FROM
     total_db_size
    JOIN total_buffer_size ON 1 = 1;
    """,
    []
  )
```

### Evaluate the results in English

This section gives recommendations for buffer allocation and instance sizing.

```elixir
# IO.inspect(data_vs_buffer)
[[total_db_size, total_buffer_size, data_percentage]] = data_vs_buffer.rows

if data_percentage > 100.0 do
  "Data is larger than available buffers.  Consider a larger instance size or adjust available buffers."
else
  if data_percentage > 90.0 do
    "Data is more than 90% of buffers.  You are almost out of buffer space."
  else
    "Data fits within buffers."
  end
end
```

## WAL

Wal log info

<!-- livebook:{"attrs":"eyJjYWNoZV9xdWVyeSI6dHJ1ZSwiY29ubmVjdGlvbiI6eyJ0eXBlIjoicG9zdGdyZXMiLCJ2YXJpYWJsZSI6ImNvbm4ifSwicXVlcnkiOiJTRUxFQ1QgYXJjaGl2ZWRfY291bnQsIFxuIENPQUxFU0NFKGxhc3RfYXJjaGl2ZWRfd2FsLCAnJyksXG4gQ09BTEVTQ0UoRVhUUkFDVChFUE9DSCBGUk9NIGxhc3RfYXJjaGl2ZWRfdGltZSk6OmJpZ2ludCwgMCksXG4gZmFpbGVkX2NvdW50LFxuIENPQUxFU0NFKGxhc3RfZmFpbGVkX3dhbCwgJycpLFxuIENPQUxFU0NFKEVYVFJBQ1QoRVBPQ0ggRlJPTSBsYXN0X2ZhaWxlZF90aW1lKTo6YmlnaW50LCAwKSxcbiBDT0FMRVNDRShFWFRSQUNUKEVQT0NIIEZST00gc3RhdHNfcmVzZXQpOjpiaWdpbnQsIDApXG5GUk9NIHBnX3N0YXRfYXJjaGl2ZXIiLCJyZXN1bHRfdmFyaWFibGUiOiJ3YWxfaW5mbyIsInRpbWVvdXQiOm51bGx9","chunks":null,"kind":"Elixir.KinoDB.SQLCell","livebook_object":"smart_cell"} -->

```elixir
wal_info =
  Postgrex.query!(
    conn,
    """
    SELECT archived_count, 
     COALESCE(last_archived_wal, ''),
     COALESCE(EXTRACT(EPOCH FROM last_archived_time)::bigint, 0),
     failed_count,
     COALESCE(last_failed_wal, ''),
     COALESCE(EXTRACT(EPOCH FROM last_failed_time)::bigint, 0),
     COALESCE(EXTRACT(EPOCH FROM stats_reset)::bigint, 0)
    FROM pg_stat_archiver
    """,
    []
  )
```

## Unused Indexes

Here is a list of indexes that haven't been used since statistics restarted(db restart, intentional reset of stats).  If you just restarted your database wait for a few days before taking this too seriously.

<!-- livebook:{"attrs":"eyJjYWNoZV9xdWVyeSI6dHJ1ZSwiY29ubmVjdGlvbiI6eyJ0eXBlIjoicG9zdGdyZXMiLCJ2YXJpYWJsZSI6ImNvbm4ifSwicXVlcnkiOiJTRUxFQ1RcbiAgcmVsbmFtZSBBUyB0YWJsZSxcbiAgaW5kZXhyZWxuYW1lIEFTIGluZGV4LFxuICBwZ19zaXplX3ByZXR0eShwZ19yZWxhdGlvbl9zaXplKGkuaW5kZXhyZWxpZCkpIEFTIGluZGV4X3NpemUsXG4gIGlkeF9zY2FuIGFzIGluZGV4X3NjYW5zXG5GUk9NIHBnX3N0YXRfdXNlcl9pbmRleGVzIHVpXG5KT0lOIHBnX2luZGV4IGkgT04gdWkuaW5kZXhyZWxpZCA9IGkuaW5kZXhyZWxpZFxuV0hFUkUgTk9UIGluZGlzdW5pcXVlIEFORCBpZHhfc2NhbiA9MCBBTkQgcGdfcmVsYXRpb25fc2l6ZShyZWxpZCkgPiA1ICogODE5MlxuT1JERVIgQlkgcGdfcmVsYXRpb25fc2l6ZShpLmluZGV4cmVsaWQpIC8gbnVsbGlmKGlkeF9zY2FuLCAwKSBERVNDIE5VTExTIEZJUlNULFxucGdfcmVsYXRpb25fc2l6ZShpLmluZGV4cmVsaWQpIERFU0M7IiwicmVzdWx0X3ZhcmlhYmxlIjoidW51c2VkX2luZGV4ZXMiLCJ0aW1lb3V0IjpudWxsfQ","chunks":null,"kind":"Elixir.KinoDB.SQLCell","livebook_object":"smart_cell"} -->

```elixir
unused_indexes =
  Postgrex.query!(
    conn,
    """
    SELECT
      relname AS table,
      indexrelname AS index,
      pg_size_pretty(pg_relation_size(i.indexrelid)) AS index_size,
      idx_scan as index_scans
    FROM pg_stat_user_indexes ui
    JOIN pg_index i ON ui.indexrelid = i.indexrelid
    WHERE NOT indisunique AND idx_scan =0 AND pg_relation_size(relid) > 5 * 8192
    ORDER BY pg_relation_size(i.indexrelid) / nullif(idx_scan, 0) DESC NULLS FIRST,
    pg_relation_size(i.indexrelid) DESC;
    """,
    []
  )
```

Here are sample DROP INDEX commands for each of your unused indexes.
WARNING:  If this report was run right after restarting your database then the statistics may be off.  Wait for a bit before dropping any indexes you think are unused.

```elixir
# IO.inspect(unused_indexes)
IO.puts(
  "-- Make sure your server has been running long enough to make a judgement on whether an index is used or not."
)

IO.puts("-- Uncomment and run the following to drop unused indexes.")

for row <- unused_indexes.rows do
  [_table, index, _, _] = row
  IO.puts("-- DROP INDEX #{index};")
end
```

## Connection Info

### Max Used Connections with Percentage

Current connection count vs max connections setting.

<!-- livebook:{"attrs":"eyJjYWNoZV9xdWVyeSI6dHJ1ZSwiY29ubmVjdGlvbiI6eyJ0eXBlIjoicG9zdGdyZXMiLCJ2YXJpYWJsZSI6ImNvbm4ifSwicXVlcnkiOiJXSVRIIGN1cnJlbnRfY29ubmVjdGlvbnMgQVMgKFxuICBTRUxFQ1QgY291bnQoMSkgQVMgdXNlZCBGUk9NIHBnX3N0YXRfYWN0aXZpdHlcbiksXG5yZXNlcnZlZF9mb3Jfc3VwZXIgQVMgKFxuICBTRUxFQ1Qgc2V0dGluZzo6aW50IEFTIHJlc19mb3Jfc3VwZXIgRlJPTSBwZ19zZXR0aW5ncyBXSEVSRSBuYW1lID0gJ3N1cGVydXNlcl9yZXNlcnZlZF9jb25uZWN0aW9ucydcbiksXG5tYXhfY29ubmVjdGlvbnMgQVMgKFxuICBTRUxFQ1Qgc2V0dGluZzo6aW50IEFTIG1heF9jb25uZWN0aW9ucyBGUk9NIHBnX3NldHRpbmdzIFdIRVJFIG5hbWUgPSAnbWF4X2Nvbm5lY3Rpb25zJ1xuKVxuU0VMRUNUXG4gY3VycmVudF9jb25uZWN0aW9ucy51c2VkLFxuIHJlc2VydmVkX2Zvcl9zdXBlci5yZXNfZm9yX3N1cGVyIEFTIHJlc2VydmVkX2Zvcl9zdXBlcixcbiBtYXhfY29ubmVjdGlvbnMubWF4X2Nvbm5lY3Rpb25zLFxuICgoY3VycmVudF9jb25uZWN0aW9ucy51c2VkOjpmbG9hdCArIDEpIC8gKHJlc2VydmVkX2Zvcl9zdXBlci5yZXNfZm9yX3N1cGVyOjpmbG9hdCArIG1heF9jb25uZWN0aW9ucy5tYXhfY29ubmVjdGlvbnM6OmZsb2F0ICsgMSkgKiAxMDAuMCkgQVMgcGN0X3VzZWRcbkZST01cbiBjdXJyZW50X2Nvbm5lY3Rpb25zXG5KT0lOXG4gcmVzZXJ2ZWRfZm9yX3N1cGVyIE9OIDEgPSAxXG5KT0lOXG4gbWF4X2Nvbm5lY3Rpb25zIE9OIDEgPSAxIiwicmVzdWx0X3ZhcmlhYmxlIjoibWF4X3VzZWQiLCJ0aW1lb3V0IjpudWxsfQ","chunks":null,"kind":"Elixir.KinoDB.SQLCell","livebook_object":"smart_cell"} -->

```elixir
max_used =
  Postgrex.query!(
    conn,
    """
    WITH current_connections AS (
      SELECT count(1) AS used FROM pg_stat_activity
    ),
    reserved_for_super AS (
      SELECT setting::int AS res_for_super FROM pg_settings WHERE name = 'superuser_reserved_connections'
    ),
    max_connections AS (
      SELECT setting::int AS max_connections FROM pg_settings WHERE name = 'max_connections'
    )
    SELECT
     current_connections.used,
     reserved_for_super.res_for_super AS reserved_for_super,
     max_connections.max_connections,
     ((current_connections.used::float + 1) / (reserved_for_super.res_for_super::float + max_connections.max_connections::float + 1) * 100.0) AS pct_used
    FROM
     current_connections
    JOIN
     reserved_for_super ON 1 = 1
    JOIN
     max_connections ON 1 = 1
    """,
    []
  )
```

### Connections per DB

This is the number of active connections per DB.  Make sure this matches expectations.  If other groups are using your database more than you would like an API would be a good suggestion.

<!-- livebook:{"attrs":"eyJjYWNoZV9xdWVyeSI6dHJ1ZSwiY29ubmVjdGlvbiI6eyJ0eXBlIjoicG9zdGdyZXMiLCJ2YXJpYWJsZSI6ImNvbm4ifSwicXVlcnkiOiJTRUxFQ1RcbiBkYXRuYW1lLFxuIG51bWJhY2tlbmRzIFxuRlJPTVxuIHBnX3N0YXRfZGF0YWJhc2UgXG5XSEVSRVxuIGRhdG5hbWUgSVMgTk9UIE5VTEwgQU5EIFxuIGRhdG5hbWUgTk9UIElOICgndGVtcGxhdGUwJywgJ3RlbXBsYXRlMScsICdwb3N0Z3JlcycpOyIsInJlc3VsdF92YXJpYWJsZSI6ImNvbm5lY3Rpb25zX3Blcl9kYiIsInRpbWVvdXQiOm51bGx9","chunks":null,"kind":"Elixir.KinoDB.SQLCell","livebook_object":"smart_cell"} -->

```elixir
connections_per_db =
  Postgrex.query!(
    conn,
    """
    SELECT
     datname,
     numbackends 
    FROM
     pg_stat_database 
    WHERE
     datname IS NOT NULL AND 
     datname NOT IN ('template0', 'template1', 'postgres');
    """,
    []
  )
```

<!-- livebook:{"attrs":"eyJjaGFydF90aXRsZSI6IkNvbm5lY3Rpb25zIHBlciBEQiIsImhlaWdodCI6bnVsbCwibGF5ZXJzIjpbeyJhY3RpdmUiOnRydWUsImNoYXJ0X3R5cGUiOiJiYXIiLCJjb2xvcl9maWVsZCI6bnVsbCwiY29sb3JfZmllbGRfYWdncmVnYXRlIjpudWxsLCJjb2xvcl9maWVsZF9iaW4iOm51bGwsImNvbG9yX2ZpZWxkX3NjYWxlX3NjaGVtZSI6bnVsbCwiY29sb3JfZmllbGRfdHlwZSI6bnVsbCwiZGF0YV92YXJpYWJsZSI6ImNvbm5lY3Rpb25zX3Blcl9kYiIsImdlb2RhdGFfY29sb3IiOiJibHVlIiwibGF0aXR1ZGVfZmllbGQiOm51bGwsImxvbmdpdHVkZV9maWVsZCI6bnVsbCwieF9maWVsZCI6ImRhdG5hbWUiLCJ4X2ZpZWxkX2FnZ3JlZ2F0ZSI6bnVsbCwieF9maWVsZF9iaW4iOm51bGwsInhfZmllbGRfc2NhbGVfdHlwZSI6bnVsbCwieF9maWVsZF90eXBlIjoibm9taW5hbCIsInlfZmllbGQiOiJudW1iYWNrZW5kcyIsInlfZmllbGRfYWdncmVnYXRlIjpudWxsLCJ5X2ZpZWxkX2JpbiI6bnVsbCwieV9maWVsZF9zY2FsZV90eXBlIjpudWxsLCJ5X2ZpZWxkX3R5cGUiOiJxdWFudGl0YXRpdmUifV0sInZsX2FsaWFzIjoiRWxpeGlyLlZlZ2FMaXRlIiwid2lkdGgiOjcwMH0","chunks":null,"kind":"Elixir.KinoVegaLite.ChartCell","livebook_object":"smart_cell"} -->

```elixir
VegaLite.new(width: 700, title: "Connections per DB")
|> VegaLite.data_from_values(connections_per_db, only: ["datname", "numbackends"])
|> VegaLite.mark(:bar)
|> VegaLite.encode_field(:x, "datname", type: :nominal)
|> VegaLite.encode_field(:y, "numbackends", type: :quantitative)
```

## PostgreSQL Memory Usage

Memory/Buffer Usage information

### Buffer Pool Usage - DB

How frequently are my blocks read from disk vs buffers?  If this percentage is low consider more memory or larger instance size.  This needs to be run against a database that's been up for days or months.

<!-- livebook:{"attrs":"eyJjYWNoZV9xdWVyeSI6dHJ1ZSwiY29ubmVjdGlvbiI6eyJ0eXBlIjoicG9zdGdyZXMiLCJ2YXJpYWJsZSI6ImNvbm4ifSwicXVlcnkiOiJTRUxFQ1QgXG4gZGF0bmFtZSxcbiBibGtzX3JlYWQgQVMgcmVhZF9mcm9tX2Rpc2ssXG4gYmxrc19oaXQgQVMgcmVhZF9mcm9tX2J1ZmZlcixcbiAoKGJsa3NfcmVhZDo6ZmxvYXQgKyAxLjApIC8gKChibGtzX3JlYWQ6OmZsb2F0ICsgYmxrc19oaXQ6OmZsb2F0ICsgMS4wKSkgKiAxMDA6OmZsb2F0KSBBUyBwZXJjZW50YWdlX2Zyb21fZGlza1xuRlJPTVxuIHBnX3N0YXRfZGF0YWJhc2VcbldIRVJFXG4gZGF0bmFtZSBJUyBOT1QgTlVMTCBBTkRcbiBkYXRuYW1lIE5PVCBJTiAoJ3Bvc3RncmVzJywgJ3RlbXBsYXRlMCcsICd0ZW1wbGF0ZTEnKVxuT1JERVIgQlkgNCBERVNDOyIsInJlc3VsdF92YXJpYWJsZSI6ImJ1ZmZlcl9wb29sX3VzYWdlX2RiIiwidGltZW91dCI6bnVsbH0","chunks":null,"kind":"Elixir.KinoDB.SQLCell","livebook_object":"smart_cell"} -->

```elixir
buffer_pool_usage_db =
  Postgrex.query!(
    conn,
    """
    SELECT 
     datname,
     blks_read AS read_from_disk,
     blks_hit AS read_from_buffer,
     ((blks_read::float + 1.0) / ((blks_read::float + blks_hit::float + 1.0)) * 100::float) AS percentage_from_disk
    FROM
     pg_stat_database
    WHERE
     datname IS NOT NULL AND
     datname NOT IN ('postgres', 'template0', 'template1')
    ORDER BY 4 DESC;
    """,
    []
  )
```

<!-- livebook:{"attrs":"eyJjaGFydF90aXRsZSI6IkJ1ZmZlciBQb29sIFVzYWdlIGJ5IERCIiwiaGVpZ2h0IjpudWxsLCJsYXllcnMiOlt7ImFjdGl2ZSI6dHJ1ZSwiY2hhcnRfdHlwZSI6ImJhciIsImNvbG9yX2ZpZWxkIjpudWxsLCJjb2xvcl9maWVsZF9hZ2dyZWdhdGUiOm51bGwsImNvbG9yX2ZpZWxkX2JpbiI6bnVsbCwiY29sb3JfZmllbGRfc2NhbGVfc2NoZW1lIjpudWxsLCJjb2xvcl9maWVsZF90eXBlIjpudWxsLCJkYXRhX3ZhcmlhYmxlIjoiYnVmZmVyX3Bvb2xfdXNhZ2VfZGIiLCJnZW9kYXRhX2NvbG9yIjoiYmx1ZSIsImxhdGl0dWRlX2ZpZWxkIjpudWxsLCJsb25naXR1ZGVfZmllbGQiOm51bGwsInhfZmllbGQiOiJkYXRuYW1lIiwieF9maWVsZF9hZ2dyZWdhdGUiOm51bGwsInhfZmllbGRfYmluIjpudWxsLCJ4X2ZpZWxkX3NjYWxlX3R5cGUiOm51bGwsInhfZmllbGRfdHlwZSI6Im5vbWluYWwiLCJ5X2ZpZWxkIjoicGVyY2VudGFnZV9mcm9tX2Rpc2siLCJ5X2ZpZWxkX2FnZ3JlZ2F0ZSI6bnVsbCwieV9maWVsZF9iaW4iOm51bGwsInlfZmllbGRfc2NhbGVfdHlwZSI6bnVsbCwieV9maWVsZF90eXBlIjoicXVhbnRpdGF0aXZlIn1dLCJ2bF9hbGlhcyI6IkVsaXhpci5WZWdhTGl0ZSIsIndpZHRoIjo3MDB9","chunks":null,"kind":"Elixir.KinoVegaLite.ChartCell","livebook_object":"smart_cell"} -->

```elixir
VegaLite.new(width: 700, title: "Buffer Pool Usage by DB")
|> VegaLite.data_from_values(buffer_pool_usage_db,
  only: ["datname", "percentage_from_disk"]
)
|> VegaLite.mark(:bar)
|> VegaLite.encode_field(:x, "datname", type: :nominal)
|> VegaLite.encode_field(:y, "percentage_from_disk", type: :quantitative)
```

### Buffer Pool Usage - Tables

<!-- livebook:{"break_markdown":true} -->

Break down buffer usage by table.  Which of my tables fit in memory and which do not?

<!-- livebook:{"attrs":"eyJjYWNoZV9xdWVyeSI6dHJ1ZSwiY29ubmVjdGlvbiI6eyJ0eXBlIjoicG9zdGdyZXMiLCJ2YXJpYWJsZSI6ImNvbm4ifSwicXVlcnkiOiJTRUxFQ1RcbiBzY2hlbWFuYW1lLFxuIHJlbG5hbWUsIFxuIGhlYXBfYmxrc19yZWFkLCBcbiBoZWFwX2Jsa3NfaGl0LFxuICgoaGVhcF9ibGtzX3JlYWQ6OmZsb2F0ICsgMS4wKSAvIChoZWFwX2Jsa3NfcmVhZDo6ZmxvYXQgKyBoZWFwX2Jsa3NfaGl0OjpmbG9hdCArIDEuMCkgKiAxMDAuMCkgQVMgcGVyY2VudGFnZV9mcm9tX2Rpc2tcbkZST01cbiBwZ19zdGF0aW9fdXNlcl90YWJsZXNcbk9SREVSIEJZIDUgREVTQzsiLCJyZXN1bHRfdmFyaWFibGUiOiJidWZmZXJfcG9vbF91c2FnZV90YWJsZXMiLCJ0aW1lb3V0IjpudWxsfQ","chunks":null,"kind":"Elixir.KinoDB.SQLCell","livebook_object":"smart_cell"} -->

```elixir
buffer_pool_usage_tables =
  Postgrex.query!(
    conn,
    """
    SELECT
     schemaname,
     relname, 
     heap_blks_read, 
     heap_blks_hit,
     ((heap_blks_read::float + 1.0) / (heap_blks_read::float + heap_blks_hit::float + 1.0) * 100.0) AS percentage_from_disk
    FROM
     pg_statio_user_tables
    ORDER BY 5 DESC;
    """,
    []
  )
```

<!-- livebook:{"attrs":"eyJjaGFydF90aXRsZSI6IkJ1ZmZlciBQb29sIFVzYWdlIGJ5IFRhYmxlIiwiaGVpZ2h0IjpudWxsLCJsYXllcnMiOlt7ImFjdGl2ZSI6dHJ1ZSwiY2hhcnRfdHlwZSI6ImJhciIsImNvbG9yX2ZpZWxkIjpudWxsLCJjb2xvcl9maWVsZF9hZ2dyZWdhdGUiOm51bGwsImNvbG9yX2ZpZWxkX2JpbiI6bnVsbCwiY29sb3JfZmllbGRfc2NhbGVfc2NoZW1lIjpudWxsLCJjb2xvcl9maWVsZF90eXBlIjpudWxsLCJkYXRhX3ZhcmlhYmxlIjoiYnVmZmVyX3Bvb2xfdXNhZ2VfdGFibGVzIiwiZ2VvZGF0YV9jb2xvciI6ImJsdWUiLCJsYXRpdHVkZV9maWVsZCI6bnVsbCwibG9uZ2l0dWRlX2ZpZWxkIjpudWxsLCJ4X2ZpZWxkIjoicmVsbmFtZSIsInhfZmllbGRfYWdncmVnYXRlIjpudWxsLCJ4X2ZpZWxkX2JpbiI6bnVsbCwieF9maWVsZF9zY2FsZV90eXBlIjpudWxsLCJ4X2ZpZWxkX3R5cGUiOiJub21pbmFsIiwieV9maWVsZCI6InBlcmNlbnRhZ2VfZnJvbV9kaXNrIiwieV9maWVsZF9hZ2dyZWdhdGUiOm51bGwsInlfZmllbGRfYmluIjpudWxsLCJ5X2ZpZWxkX3NjYWxlX3R5cGUiOm51bGwsInlfZmllbGRfdHlwZSI6InF1YW50aXRhdGl2ZSJ9XSwidmxfYWxpYXMiOiJFbGl4aXIuVmVnYUxpdGUiLCJ3aWR0aCI6NzAwfQ","chunks":null,"kind":"Elixir.KinoVegaLite.ChartCell","livebook_object":"smart_cell"} -->

```elixir
VegaLite.new(width: 700, title: "Buffer Pool Usage by Table")
|> VegaLite.data_from_values(buffer_pool_usage_tables,
  only: ["relname", "percentage_from_disk"]
)
|> VegaLite.mark(:bar)
|> VegaLite.encode_field(:x, "relname", type: :nominal)
|> VegaLite.encode_field(:y, "percentage_from_disk", type: :quantitative)
```

### Buffer Pool Usage - Indexes

This is more important than tables.  Do all of my indexes fit in memory?  What percentage of time are they coming from memory vs disk?

<!-- livebook:{"attrs":"eyJjYWNoZV9xdWVyeSI6dHJ1ZSwiY29ubmVjdGlvbiI6eyJ0eXBlIjoicG9zdGdyZXMiLCJ2YXJpYWJsZSI6ImNvbm4ifSwicXVlcnkiOiJTRUxFQ1RcbiBzY2hlbWFuYW1lLFxuIHJlbG5hbWUsIFxuIGlkeF9ibGtzX3JlYWQsIFxuIGlkeF9ibGtzX2hpdCxcbiAoKGlkeF9ibGtzX3JlYWQ6OmZsb2F0ICsgMS4wKSAvIChpZHhfYmxrc19yZWFkOjpmbG9hdCArIGlkeF9ibGtzX2hpdDo6ZmxvYXQgKyAxLjApICogMTAwLjApIEFTIHBlcmNlbnRhZ2VfZnJvbV9kaXNrXG5GUk9NXG4gcGdfc3RhdGlvX3VzZXJfdGFibGVzXG5PUkRFUiBCWSA1IERFU0M7IiwicmVzdWx0X3ZhcmlhYmxlIjoiYnVmZmVyX3Bvb2xfdXNhZ2VfaW5kZXhlcyIsInRpbWVvdXQiOm51bGx9","chunks":null,"kind":"Elixir.KinoDB.SQLCell","livebook_object":"smart_cell"} -->

```elixir
buffer_pool_usage_indexes =
  Postgrex.query!(
    conn,
    """
    SELECT
     schemaname,
     relname, 
     idx_blks_read, 
     idx_blks_hit,
     ((idx_blks_read::float + 1.0) / (idx_blks_read::float + idx_blks_hit::float + 1.0) * 100.0) AS percentage_from_disk
    FROM
     pg_statio_user_tables
    ORDER BY 5 DESC;
    """,
    []
  )
```

<!-- livebook:{"attrs":"eyJjaGFydF90aXRsZSI6IkJ1ZmZlciBQb29sIFVzYWdlIC0gSW5kZXhlcyIsImhlaWdodCI6bnVsbCwibGF5ZXJzIjpbeyJhY3RpdmUiOnRydWUsImNoYXJ0X3R5cGUiOiJiYXIiLCJjb2xvcl9maWVsZCI6bnVsbCwiY29sb3JfZmllbGRfYWdncmVnYXRlIjpudWxsLCJjb2xvcl9maWVsZF9iaW4iOm51bGwsImNvbG9yX2ZpZWxkX3NjYWxlX3NjaGVtZSI6bnVsbCwiY29sb3JfZmllbGRfdHlwZSI6bnVsbCwiZGF0YV92YXJpYWJsZSI6ImJ1ZmZlcl9wb29sX3VzYWdlX2luZGV4ZXMiLCJnZW9kYXRhX2NvbG9yIjoiYmx1ZSIsImxhdGl0dWRlX2ZpZWxkIjpudWxsLCJsb25naXR1ZGVfZmllbGQiOm51bGwsInhfZmllbGQiOiJyZWxuYW1lIiwieF9maWVsZF9hZ2dyZWdhdGUiOm51bGwsInhfZmllbGRfYmluIjpudWxsLCJ4X2ZpZWxkX3NjYWxlX3R5cGUiOm51bGwsInhfZmllbGRfdHlwZSI6Im5vbWluYWwiLCJ5X2ZpZWxkIjoicGVyY2VudGFnZV9mcm9tX2Rpc2siLCJ5X2ZpZWxkX2FnZ3JlZ2F0ZSI6bnVsbCwieV9maWVsZF9iaW4iOm51bGwsInlfZmllbGRfc2NhbGVfdHlwZSI6bnVsbCwieV9maWVsZF90eXBlIjoicXVhbnRpdGF0aXZlIn1dLCJ2bF9hbGlhcyI6IkVsaXhpci5WZWdhTGl0ZSIsIndpZHRoIjo3MDB9","chunks":null,"kind":"Elixir.KinoVegaLite.ChartCell","livebook_object":"smart_cell"} -->

```elixir
VegaLite.new(width: 700, title: "Buffer Pool Usage - Indexes")
|> VegaLite.data_from_values(buffer_pool_usage_indexes,
  only: ["relname", "percentage_from_disk"]
)
|> VegaLite.mark(:bar)
|> VegaLite.encode_field(:x, "relname", type: :nominal)
|> VegaLite.encode_field(:y, "percentage_from_disk", type: :quantitative)
```

## Index / Table Scans

### Index Usage By Table

What percentage of my queries are using indexes broken down by table?

<!-- livebook:{"attrs":"eyJjYWNoZV9xdWVyeSI6dHJ1ZSwiY29ubmVjdGlvbiI6eyJ0eXBlIjoicG9zdGdyZXMiLCJ2YXJpYWJsZSI6ImNvbm4ifSwicXVlcnkiOiJTRUxFQ1RcbiBzY2hlbWFuYW1lLFxuIHJlbG5hbWUsXG4gc2VxX3NjYW4sXG4gaWR4X3NjYW4sXG4gKChzZXFfc2Nhbjo6ZmxvYXQgKyAxLjApIC8gKHNlcV9zY2FuOjpmbG9hdCArIGlkeF9zY2FuOjpmbG9hdCArIDEuMCkgKiAxMDAuMCkgQVMgc2VxX3NjYW5fcGVyY2VudGFnZVxuRlJPTVxuIHBnX3N0YXRfdXNlcl90YWJsZXNcbk9SREVSIEJZIDUgREVTQzsiLCJyZXN1bHRfdmFyaWFibGUiOiJpbmRleF91c2FnZV9ieV90YWJsZSIsInRpbWVvdXQiOm51bGx9","chunks":null,"kind":"Elixir.KinoDB.SQLCell","livebook_object":"smart_cell"} -->

```elixir
index_usage_by_table =
  Postgrex.query!(
    conn,
    """
    SELECT
     schemaname,
     relname,
     seq_scan,
     idx_scan,
     ((seq_scan::float + 1.0) / (seq_scan::float + idx_scan::float + 1.0) * 100.0) AS seq_scan_percentage
    FROM
     pg_stat_user_tables
    ORDER BY 5 DESC;
    """,
    []
  )
```

<!-- livebook:{"attrs":"eyJjaGFydF90aXRsZSI6IkluZGV4IFVzYWdlIGJ5IFRhYmxlIiwiaGVpZ2h0IjpudWxsLCJsYXllcnMiOlt7ImFjdGl2ZSI6dHJ1ZSwiY2hhcnRfdHlwZSI6ImJhciIsImNvbG9yX2ZpZWxkIjpudWxsLCJjb2xvcl9maWVsZF9hZ2dyZWdhdGUiOm51bGwsImNvbG9yX2ZpZWxkX2JpbiI6bnVsbCwiY29sb3JfZmllbGRfc2NhbGVfc2NoZW1lIjpudWxsLCJjb2xvcl9maWVsZF90eXBlIjpudWxsLCJkYXRhX3ZhcmlhYmxlIjoiaW5kZXhfdXNhZ2VfYnlfdGFibGUiLCJnZW9kYXRhX2NvbG9yIjoiYmx1ZSIsImxhdGl0dWRlX2ZpZWxkIjpudWxsLCJsb25naXR1ZGVfZmllbGQiOm51bGwsInhfZmllbGQiOiJyZWxuYW1lIiwieF9maWVsZF9hZ2dyZWdhdGUiOm51bGwsInhfZmllbGRfYmluIjpudWxsLCJ4X2ZpZWxkX3NjYWxlX3R5cGUiOm51bGwsInhfZmllbGRfdHlwZSI6Im5vbWluYWwiLCJ5X2ZpZWxkIjoic2VxX3NjYW5fcGVyY2VudGFnZSIsInlfZmllbGRfYWdncmVnYXRlIjpudWxsLCJ5X2ZpZWxkX2JpbiI6bnVsbCwieV9maWVsZF9zY2FsZV90eXBlIjpudWxsLCJ5X2ZpZWxkX3R5cGUiOiJxdWFudGl0YXRpdmUifV0sInZsX2FsaWFzIjoiRWxpeGlyLlZlZ2FMaXRlIiwid2lkdGgiOjcwMH0","chunks":null,"kind":"Elixir.KinoVegaLite.ChartCell","livebook_object":"smart_cell"} -->

```elixir
VegaLite.new(width: 700, title: "Index Usage by Table")
|> VegaLite.data_from_values(index_usage_by_table,
  only: ["relname", "seq_scan_percentage"]
)
|> VegaLite.mark(:bar)
|> VegaLite.encode_field(:x, "relname", type: :nominal)
|> VegaLite.encode_field(:y, "seq_scan_percentage", type: :quantitative)
```

### Index Usage by Index

Use this to find the most used indexes

<!-- livebook:{"attrs":"eyJjYWNoZV9xdWVyeSI6dHJ1ZSwiY29ubmVjdGlvbiI6eyJ0eXBlIjoicG9zdGdyZXMiLCJ2YXJpYWJsZSI6ImNvbm4ifSwicXVlcnkiOiJTRUxFQ1RcbiBzY2hlbWFuYW1lLFxuIHJlbG5hbWUsXG4gaW5kZXhyZWxuYW1lLFxuIGlkeF9zY2FuXG5GUk9NXG4gcGdfc3RhdF91c2VyX2luZGV4ZXNcbldIRVJFIGlkeF9zY2FuID4gMFxuT1JERVIgQllcbiBpZHhfc2NhbiBERVNDOyIsInJlc3VsdF92YXJpYWJsZSI6ImluZGV4X3VzYWdlX2J5X2luZGV4IiwidGltZW91dCI6bnVsbH0","chunks":null,"kind":"Elixir.KinoDB.SQLCell","livebook_object":"smart_cell"} -->

```elixir
index_usage_by_index =
  Postgrex.query!(
    conn,
    """
    SELECT
     schemaname,
     relname,
     indexrelname,
     idx_scan
    FROM
     pg_stat_user_indexes
    WHERE idx_scan > 0
    ORDER BY
     idx_scan DESC;
    """,
    []
  )
```

<!-- livebook:{"attrs":"eyJjaGFydF90aXRsZSI6IkluZGV4IFVzYWdlIGJ5IEluZGV4IiwiaGVpZ2h0IjpudWxsLCJsYXllcnMiOlt7ImFjdGl2ZSI6dHJ1ZSwiY2hhcnRfdHlwZSI6ImJhciIsImNvbG9yX2ZpZWxkIjpudWxsLCJjb2xvcl9maWVsZF9hZ2dyZWdhdGUiOm51bGwsImNvbG9yX2ZpZWxkX2JpbiI6bnVsbCwiY29sb3JfZmllbGRfc2NhbGVfc2NoZW1lIjpudWxsLCJjb2xvcl9maWVsZF90eXBlIjpudWxsLCJkYXRhX3ZhcmlhYmxlIjoiaW5kZXhfdXNhZ2VfYnlfaW5kZXgiLCJnZW9kYXRhX2NvbG9yIjoiYmx1ZSIsImxhdGl0dWRlX2ZpZWxkIjpudWxsLCJsb25naXR1ZGVfZmllbGQiOm51bGwsInhfZmllbGQiOiJpbmRleHJlbG5hbWUiLCJ4X2ZpZWxkX2FnZ3JlZ2F0ZSI6bnVsbCwieF9maWVsZF9iaW4iOm51bGwsInhfZmllbGRfc2NhbGVfdHlwZSI6bnVsbCwieF9maWVsZF90eXBlIjoibm9taW5hbCIsInlfZmllbGQiOiJpZHhfc2NhbiIsInlfZmllbGRfYWdncmVnYXRlIjpudWxsLCJ5X2ZpZWxkX2JpbiI6bnVsbCwieV9maWVsZF9zY2FsZV90eXBlIjpudWxsLCJ5X2ZpZWxkX3R5cGUiOiJxdWFudGl0YXRpdmUifV0sInZsX2FsaWFzIjoiRWxpeGlyLlZlZ2FMaXRlIiwid2lkdGgiOjcwMH0","chunks":null,"kind":"Elixir.KinoVegaLite.ChartCell","livebook_object":"smart_cell"} -->

```elixir
VegaLite.new(width: 700, title: "Index Usage by Index")
|> VegaLite.data_from_values(index_usage_by_index, only: ["indexrelname", "idx_scan"])
|> VegaLite.mark(:bar)
|> VegaLite.encode_field(:x, "indexrelname", type: :nominal)
|> VegaLite.encode_field(:y, "idx_scan", type: :quantitative)
```

## Developer Scorecard

How often do queries go to production that don't use indexes?  What percentage of my queries are using an index?  How much this affects you depends on data size and load, but many large databases do 10k+ reads/sec.  Even 1% table scans of that would be catastrophic.  Blogs can get by with never using indexes.  It depends on the purpose of the database, but this is definitely a number to watch.

<!-- livebook:{"attrs":"eyJjYWNoZV9xdWVyeSI6dHJ1ZSwiY29ubmVjdGlvbiI6eyJ0eXBlIjoicG9zdGdyZXMiLCJ2YXJpYWJsZSI6ImNvbm4ifSwicXVlcnkiOiJTRUxFQ1RcbiBhdmcoKHNlcV9zY2FuOjpmbG9hdCArIDEuMCkgLyAoc2VxX3NjYW46OmZsb2F0ICsgaWR4X3NjYW46OmZsb2F0ICsgMS4wKSAqIDEwMC4wKSBBUyBvdmVyYWxsX3Njb3JlY2FyZFxuRlJPTVxuIHBnX3N0YXRfdXNlcl90YWJsZXM7IiwicmVzdWx0X3ZhcmlhYmxlIjoiZGV2ZWxvcGVyX3Njb3JlY2FyZCIsInRpbWVvdXQiOm51bGx9","chunks":null,"kind":"Elixir.KinoDB.SQLCell","livebook_object":"smart_cell"} -->

```elixir
developer_scorecard =
  Postgrex.query!(
    conn,
    """
    SELECT
     avg((seq_scan::float + 1.0) / (seq_scan::float + idx_scan::float + 1.0) * 100.0) AS overall_scorecard
    FROM
     pg_stat_user_tables;
    """,
    []
  )
```

```elixir
# IO.inspect(developer_scorecard.rows)
[[scorecard]] = developer_scorecard.rows
# IO.inspect scorecard
if scorecard > 1 do
  "More than 1% of your queries are NOT using an index. Consider adding indexes and optimizing your queries."
else
  "Fewer than 1% of your queries are NOT using an index."
end
```

## Query Analytics

### Enabling pg_stat_statements

If you wish to use the next few queries you'll need pg_stat_statements enabled.  Follow this guide to do so:  [Guide](https://www.postgresql.org/docs/current/pgstatstatements.html)
Note:  If you use AWS it's likely already enabled.

<!-- livebook:{"break_markdown":true} -->

### Trouble queries by AVG Exec Time

<!-- livebook:{"attrs":"eyJjYWNoZV9xdWVyeSI6dHJ1ZSwiY29ubmVjdGlvbiI6eyJ0eXBlIjoicG9zdGdyZXMiLCJ2YXJpYWJsZSI6ImNvbm4ifSwicXVlcnkiOiJTRUxFQ1RcbiBxdWVyeSwgXG4gY2FsbHMsIFxuICh0b3RhbF9leGVjX3RpbWU6OmZsb2F0L2NhbGxzOjpmbG9hdCk6OmZsb2F0IEFTIGF2Z190aW1lX21zLFxuIHRvdGFsX2V4ZWNfdGltZVxuRlJPTVxuIHBnX3N0YXRfc3RhdGVtZW50c1xuV0hFUkVcbiBjYWxscyA+IDEwMDBcbk9SREVSIEJZIGF2Z190aW1lX21zIERFU0NcbkxJTUlUIDEwMDsiLCJyZXN1bHRfdmFyaWFibGUiOiJ0cm91YmxlX3F1ZXJpZXNfYXZnIiwidGltZW91dCI6bnVsbH0","chunks":null,"kind":"Elixir.KinoDB.SQLCell","livebook_object":"smart_cell"} -->

```elixir
trouble_queries_avg =
  Postgrex.query!(
    conn,
    """
    SELECT
     query, 
     calls, 
     (total_exec_time::float/calls::float)::float AS avg_time_ms,
     total_exec_time
    FROM
     pg_stat_statements
    WHERE
     calls > 1000
    ORDER BY avg_time_ms DESC
    LIMIT 100;
    """,
    []
  )
```

### Trouble queries by Total Exec Time

<!-- livebook:{"attrs":"eyJjYWNoZV9xdWVyeSI6dHJ1ZSwiY29ubmVjdGlvbiI6eyJ0eXBlIjoicG9zdGdyZXMiLCJ2YXJpYWJsZSI6ImNvbm4ifSwicXVlcnkiOiJTRUxFQ1RcbiBxdWVyeSwgXG4gY2FsbHMsIFxuICh0b3RhbF9leGVjX3RpbWU6OmZsb2F0L2NhbGxzOjpmbG9hdCk6OmZsb2F0IEFTIGF2Z190aW1lX21zLFxuIHRvdGFsX2V4ZWNfdGltZVxuRlJPTVxuIHBnX3N0YXRfc3RhdGVtZW50c1xuV0hFUkVcbiBjYWxscyA+IDEwMDBcbk9SREVSIEJZIHRvdGFsX2V4ZWNfdGltZSBERVNDXG5MSU1JVCAxMDA7IiwicmVzdWx0X3ZhcmlhYmxlIjoidHJvdWJsZV9xdWVyaWVzX3RvdGFsIiwidGltZW91dCI6bnVsbH0","chunks":null,"kind":"Elixir.KinoDB.SQLCell","livebook_object":"smart_cell"} -->

```elixir
trouble_queries_total =
  Postgrex.query!(
    conn,
    """
    SELECT
     query, 
     calls, 
     (total_exec_time::float/calls::float)::float AS avg_time_ms,
     total_exec_time
    FROM
     pg_stat_statements
    WHERE
     calls > 1000
    ORDER BY total_exec_time DESC
    LIMIT 100;
    """,
    []
  )
```

## Out of Numbers

Did you know your tables and sequences can run out of numbers?  If your tables have any size to them at all it's a very real concern.  Here are the status of your numbers.  If any of your sequences/id columns show up on this list please consider bigint(bigserial).  Make sure you change the column to match the sequence.

<!-- livebook:{"attrs":"eyJjYWNoZV9xdWVyeSI6dHJ1ZSwiY29ubmVjdGlvbiI6eyJ0eXBlIjoicG9zdGdyZXMiLCJ2YXJpYWJsZSI6ImNvbm4ifSwicXVlcnkiOiJTRUxFQ1RcbiBzY2hlbWFuYW1lLFxuIHNlcXVlbmNlbmFtZSxcbiBkYXRhX3R5cGUsXG4gbWF4X3ZhbHVlLFxuIGxhc3RfdmFsdWUsXG4gKGxhc3RfdmFsdWU6OmZsb2F0IC8gbWF4X3ZhbHVlOjpmbG9hdCkgQVMgcGN0X3VzZWRcbkZST00gcGdfc2VxdWVuY2VzXG5XSEVSRVxuIChsYXN0X3ZhbHVlOjpmbG9hdCAvIG1heF92YWx1ZTo6ZmxvYXQpID4gNzA7IiwicmVzdWx0X3ZhcmlhYmxlIjoicmVzdWx0IiwidGltZW91dCI6bnVsbH0","chunks":null,"kind":"Elixir.KinoDB.SQLCell","livebook_object":"smart_cell"} -->

```elixir
result =
  Postgrex.query!(
    conn,
    """
    SELECT
     schemaname,
     sequencename,
     data_type,
     max_value,
     last_value,
     (last_value::float / max_value::float) AS pct_used
    FROM pg_sequences
    WHERE
     (last_value::float / max_value::float) > 70;
    """,
    []
  )
```

The bloat queries above are modified versions of the queries found [here](https://github.com/ioguix/pgsql-bloat-estimation) with the license [here](https://github.com/ioguix/pgsql-bloat-estimation/blob/master/LICENSE).  It should be noted others have included these with a warning that they may be ~10-15% inaccurate.  Once better queries for bloat are devised they will be included here.
